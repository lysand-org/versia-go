// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/versia-pub/versia-go/ent/attachment"
	"github.com/versia-pub/versia-go/ent/follow"
	"github.com/versia-pub/versia-go/ent/image"
	"github.com/versia-pub/versia-go/ent/instancemetadata"
	"github.com/versia-pub/versia-go/ent/note"
	"github.com/versia-pub/versia-go/ent/predicate"
	"github.com/versia-pub/versia-go/ent/user"
	"github.com/versia-pub/versia-go/pkg/versia"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment       = "Attachment"
	TypeFollow           = "Follow"
	TypeImage            = "Image"
	TypeInstanceMetadata = "InstanceMetadata"
	TypeNote             = "Note"
	TypeUser             = "User"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	isRemote      *bool
	uri           *string
	extensions    *versia.Extensions
	created_at    *time.Time
	updated_at    *time.Time
	description   *string
	sha256        *[]byte
	size          *int
	addsize       *int
	blurhash      *string
	height        *int
	addheight     *int
	width         *int
	addwidth      *int
	fps           *int
	addfps        *int
	mimeType      *string
	clearedFields map[string]struct{}
	author        *uuid.UUID
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*Attachment, error)
	predicates    []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsRemote sets the "isRemote" field.
func (m *AttachmentMutation) SetIsRemote(b bool) {
	m.isRemote = &b
}

// IsRemote returns the value of the "isRemote" field in the mutation.
func (m *AttachmentMutation) IsRemote() (r bool, exists bool) {
	v := m.isRemote
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemote returns the old "isRemote" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldIsRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemote: %w", err)
	}
	return oldValue.IsRemote, nil
}

// ResetIsRemote resets all changes to the "isRemote" field.
func (m *AttachmentMutation) ResetIsRemote() {
	m.isRemote = nil
}

// SetURI sets the "uri" field.
func (m *AttachmentMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *AttachmentMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *AttachmentMutation) ResetURI() {
	m.uri = nil
}

// SetExtensions sets the "extensions" field.
func (m *AttachmentMutation) SetExtensions(v versia.Extensions) {
	m.extensions = &v
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *AttachmentMutation) Extensions() (r versia.Extensions, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldExtensions(ctx context.Context) (v versia.Extensions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *AttachmentMutation) ResetExtensions() {
	m.extensions = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDescription sets the "description" field.
func (m *AttachmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AttachmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AttachmentMutation) ResetDescription() {
	m.description = nil
}

// SetSha256 sets the "sha256" field.
func (m *AttachmentMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *AttachmentMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *AttachmentMutation) ResetSha256() {
	m.sha256 = nil
}

// SetSize sets the "size" field.
func (m *AttachmentMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *AttachmentMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *AttachmentMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *AttachmentMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *AttachmentMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetBlurhash sets the "blurhash" field.
func (m *AttachmentMutation) SetBlurhash(s string) {
	m.blurhash = &s
}

// Blurhash returns the value of the "blurhash" field in the mutation.
func (m *AttachmentMutation) Blurhash() (r string, exists bool) {
	v := m.blurhash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlurhash returns the old "blurhash" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldBlurhash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlurhash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlurhash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlurhash: %w", err)
	}
	return oldValue.Blurhash, nil
}

// ClearBlurhash clears the value of the "blurhash" field.
func (m *AttachmentMutation) ClearBlurhash() {
	m.blurhash = nil
	m.clearedFields[attachment.FieldBlurhash] = struct{}{}
}

// BlurhashCleared returns if the "blurhash" field was cleared in this mutation.
func (m *AttachmentMutation) BlurhashCleared() bool {
	_, ok := m.clearedFields[attachment.FieldBlurhash]
	return ok
}

// ResetBlurhash resets all changes to the "blurhash" field.
func (m *AttachmentMutation) ResetBlurhash() {
	m.blurhash = nil
	delete(m.clearedFields, attachment.FieldBlurhash)
}

// SetHeight sets the "height" field.
func (m *AttachmentMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *AttachmentMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldHeight(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *AttachmentMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *AttachmentMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *AttachmentMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[attachment.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *AttachmentMutation) HeightCleared() bool {
	_, ok := m.clearedFields[attachment.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *AttachmentMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, attachment.FieldHeight)
}

// SetWidth sets the "width" field.
func (m *AttachmentMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *AttachmentMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldWidth(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *AttachmentMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *AttachmentMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *AttachmentMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[attachment.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *AttachmentMutation) WidthCleared() bool {
	_, ok := m.clearedFields[attachment.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *AttachmentMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, attachment.FieldWidth)
}

// SetFps sets the "fps" field.
func (m *AttachmentMutation) SetFps(i int) {
	m.fps = &i
	m.addfps = nil
}

// Fps returns the value of the "fps" field in the mutation.
func (m *AttachmentMutation) Fps() (r int, exists bool) {
	v := m.fps
	if v == nil {
		return
	}
	return *v, true
}

// OldFps returns the old "fps" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFps(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFps: %w", err)
	}
	return oldValue.Fps, nil
}

// AddFps adds i to the "fps" field.
func (m *AttachmentMutation) AddFps(i int) {
	if m.addfps != nil {
		*m.addfps += i
	} else {
		m.addfps = &i
	}
}

// AddedFps returns the value that was added to the "fps" field in this mutation.
func (m *AttachmentMutation) AddedFps() (r int, exists bool) {
	v := m.addfps
	if v == nil {
		return
	}
	return *v, true
}

// ClearFps clears the value of the "fps" field.
func (m *AttachmentMutation) ClearFps() {
	m.fps = nil
	m.addfps = nil
	m.clearedFields[attachment.FieldFps] = struct{}{}
}

// FpsCleared returns if the "fps" field was cleared in this mutation.
func (m *AttachmentMutation) FpsCleared() bool {
	_, ok := m.clearedFields[attachment.FieldFps]
	return ok
}

// ResetFps resets all changes to the "fps" field.
func (m *AttachmentMutation) ResetFps() {
	m.fps = nil
	m.addfps = nil
	delete(m.clearedFields, attachment.FieldFps)
}

// SetMimeType sets the "mimeType" field.
func (m *AttachmentMutation) SetMimeType(s string) {
	m.mimeType = &s
}

// MimeType returns the value of the "mimeType" field in the mutation.
func (m *AttachmentMutation) MimeType() (r string, exists bool) {
	v := m.mimeType
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mimeType" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mimeType" field.
func (m *AttachmentMutation) ResetMimeType() {
	m.mimeType = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *AttachmentMutation) SetAuthorID(id uuid.UUID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *AttachmentMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *AttachmentMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *AttachmentMutation) AuthorID() (id uuid.UUID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) AuthorIDs() (ids []uuid.UUID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *AttachmentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.isRemote != nil {
		fields = append(fields, attachment.FieldIsRemote)
	}
	if m.uri != nil {
		fields = append(fields, attachment.FieldURI)
	}
	if m.extensions != nil {
		fields = append(fields, attachment.FieldExtensions)
	}
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.description != nil {
		fields = append(fields, attachment.FieldDescription)
	}
	if m.sha256 != nil {
		fields = append(fields, attachment.FieldSha256)
	}
	if m.size != nil {
		fields = append(fields, attachment.FieldSize)
	}
	if m.blurhash != nil {
		fields = append(fields, attachment.FieldBlurhash)
	}
	if m.height != nil {
		fields = append(fields, attachment.FieldHeight)
	}
	if m.width != nil {
		fields = append(fields, attachment.FieldWidth)
	}
	if m.fps != nil {
		fields = append(fields, attachment.FieldFps)
	}
	if m.mimeType != nil {
		fields = append(fields, attachment.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldIsRemote:
		return m.IsRemote()
	case attachment.FieldURI:
		return m.URI()
	case attachment.FieldExtensions:
		return m.Extensions()
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldDescription:
		return m.Description()
	case attachment.FieldSha256:
		return m.Sha256()
	case attachment.FieldSize:
		return m.Size()
	case attachment.FieldBlurhash:
		return m.Blurhash()
	case attachment.FieldHeight:
		return m.Height()
	case attachment.FieldWidth:
		return m.Width()
	case attachment.FieldFps:
		return m.Fps()
	case attachment.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldIsRemote:
		return m.OldIsRemote(ctx)
	case attachment.FieldURI:
		return m.OldURI(ctx)
	case attachment.FieldExtensions:
		return m.OldExtensions(ctx)
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldDescription:
		return m.OldDescription(ctx)
	case attachment.FieldSha256:
		return m.OldSha256(ctx)
	case attachment.FieldSize:
		return m.OldSize(ctx)
	case attachment.FieldBlurhash:
		return m.OldBlurhash(ctx)
	case attachment.FieldHeight:
		return m.OldHeight(ctx)
	case attachment.FieldWidth:
		return m.OldWidth(ctx)
	case attachment.FieldFps:
		return m.OldFps(ctx)
	case attachment.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldIsRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemote(v)
		return nil
	case attachment.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case attachment.FieldExtensions:
		v, ok := value.(versia.Extensions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case attachment.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case attachment.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case attachment.FieldBlurhash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlurhash(v)
		return nil
	case attachment.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case attachment.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case attachment.FieldFps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFps(v)
		return nil
	case attachment.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, attachment.FieldSize)
	}
	if m.addheight != nil {
		fields = append(fields, attachment.FieldHeight)
	}
	if m.addwidth != nil {
		fields = append(fields, attachment.FieldWidth)
	}
	if m.addfps != nil {
		fields = append(fields, attachment.FieldFps)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldSize:
		return m.AddedSize()
	case attachment.FieldHeight:
		return m.AddedHeight()
	case attachment.FieldWidth:
		return m.AddedWidth()
	case attachment.FieldFps:
		return m.AddedFps()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case attachment.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case attachment.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case attachment.FieldFps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFps(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldBlurhash) {
		fields = append(fields, attachment.FieldBlurhash)
	}
	if m.FieldCleared(attachment.FieldHeight) {
		fields = append(fields, attachment.FieldHeight)
	}
	if m.FieldCleared(attachment.FieldWidth) {
		fields = append(fields, attachment.FieldWidth)
	}
	if m.FieldCleared(attachment.FieldFps) {
		fields = append(fields, attachment.FieldFps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldBlurhash:
		m.ClearBlurhash()
		return nil
	case attachment.FieldHeight:
		m.ClearHeight()
		return nil
	case attachment.FieldWidth:
		m.ClearWidth()
		return nil
	case attachment.FieldFps:
		m.ClearFps()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldIsRemote:
		m.ResetIsRemote()
		return nil
	case attachment.FieldURI:
		m.ResetURI()
		return nil
	case attachment.FieldExtensions:
		m.ResetExtensions()
		return nil
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldDescription:
		m.ResetDescription()
		return nil
	case attachment.FieldSha256:
		m.ResetSha256()
		return nil
	case attachment.FieldSize:
		m.ResetSize()
		return nil
	case attachment.FieldBlurhash:
		m.ResetBlurhash()
		return nil
	case attachment.FieldHeight:
		m.ResetHeight()
		return nil
	case attachment.FieldWidth:
		m.ResetWidth()
		return nil
	case attachment.FieldFps:
		m.ResetFps()
		return nil
	case attachment.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.author != nil {
		edges = append(edges, attachment.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthor {
		edges = append(edges, attachment.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// FollowMutation represents an operation that mutates the Follow nodes in the graph.
type FollowMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	isRemote        *bool
	uri             *string
	extensions      *versia.Extensions
	created_at      *time.Time
	updated_at      *time.Time
	status          *follow.Status
	clearedFields   map[string]struct{}
	follower        *uuid.UUID
	clearedfollower bool
	followee        *uuid.UUID
	clearedfollowee bool
	done            bool
	oldValue        func(context.Context) (*Follow, error)
	predicates      []predicate.Follow
}

var _ ent.Mutation = (*FollowMutation)(nil)

// followOption allows management of the mutation configuration using functional options.
type followOption func(*FollowMutation)

// newFollowMutation creates new mutation for the Follow entity.
func newFollowMutation(c config, op Op, opts ...followOption) *FollowMutation {
	m := &FollowMutation{
		config:        c,
		op:            op,
		typ:           TypeFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowID sets the ID field of the mutation.
func withFollowID(id uuid.UUID) followOption {
	return func(m *FollowMutation) {
		var (
			err   error
			once  sync.Once
			value *Follow
		)
		m.oldValue = func(ctx context.Context) (*Follow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Follow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollow sets the old Follow of the mutation.
func withFollow(node *Follow) followOption {
	return func(m *FollowMutation) {
		m.oldValue = func(context.Context) (*Follow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Follow entities.
func (m *FollowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Follow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsRemote sets the "isRemote" field.
func (m *FollowMutation) SetIsRemote(b bool) {
	m.isRemote = &b
}

// IsRemote returns the value of the "isRemote" field in the mutation.
func (m *FollowMutation) IsRemote() (r bool, exists bool) {
	v := m.isRemote
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemote returns the old "isRemote" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldIsRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemote: %w", err)
	}
	return oldValue.IsRemote, nil
}

// ResetIsRemote resets all changes to the "isRemote" field.
func (m *FollowMutation) ResetIsRemote() {
	m.isRemote = nil
}

// SetURI sets the "uri" field.
func (m *FollowMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *FollowMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *FollowMutation) ResetURI() {
	m.uri = nil
}

// SetExtensions sets the "extensions" field.
func (m *FollowMutation) SetExtensions(v versia.Extensions) {
	m.extensions = &v
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *FollowMutation) Extensions() (r versia.Extensions, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldExtensions(ctx context.Context) (v versia.Extensions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *FollowMutation) ResetExtensions() {
	m.extensions = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FollowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FollowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FollowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FollowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FollowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FollowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *FollowMutation) SetStatus(f follow.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FollowMutation) Status() (r follow.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldStatus(ctx context.Context) (v follow.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FollowMutation) ResetStatus() {
	m.status = nil
}

// SetFollowerID sets the "follower" edge to the User entity by id.
func (m *FollowMutation) SetFollowerID(id uuid.UUID) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the User entity.
func (m *FollowMutation) ClearFollower() {
	m.clearedfollower = true
}

// FollowerCleared reports if the "follower" edge to the User entity was cleared.
func (m *FollowMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *FollowMutation) FollowerID() (id uuid.UUID, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *FollowMutation) FollowerIDs() (ids []uuid.UUID) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *FollowMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFolloweeID sets the "followee" edge to the User entity by id.
func (m *FollowMutation) SetFolloweeID(id uuid.UUID) {
	m.followee = &id
}

// ClearFollowee clears the "followee" edge to the User entity.
func (m *FollowMutation) ClearFollowee() {
	m.clearedfollowee = true
}

// FolloweeCleared reports if the "followee" edge to the User entity was cleared.
func (m *FollowMutation) FolloweeCleared() bool {
	return m.clearedfollowee
}

// FolloweeID returns the "followee" edge ID in the mutation.
func (m *FollowMutation) FolloweeID() (id uuid.UUID, exists bool) {
	if m.followee != nil {
		return *m.followee, true
	}
	return
}

// FolloweeIDs returns the "followee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FolloweeID instead. It exists only for internal usage by the builders.
func (m *FollowMutation) FolloweeIDs() (ids []uuid.UUID) {
	if id := m.followee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowee resets all changes to the "followee" edge.
func (m *FollowMutation) ResetFollowee() {
	m.followee = nil
	m.clearedfollowee = false
}

// Where appends a list predicates to the FollowMutation builder.
func (m *FollowMutation) Where(ps ...predicate.Follow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Follow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Follow).
func (m *FollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.isRemote != nil {
		fields = append(fields, follow.FieldIsRemote)
	}
	if m.uri != nil {
		fields = append(fields, follow.FieldURI)
	}
	if m.extensions != nil {
		fields = append(fields, follow.FieldExtensions)
	}
	if m.created_at != nil {
		fields = append(fields, follow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, follow.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, follow.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case follow.FieldIsRemote:
		return m.IsRemote()
	case follow.FieldURI:
		return m.URI()
	case follow.FieldExtensions:
		return m.Extensions()
	case follow.FieldCreatedAt:
		return m.CreatedAt()
	case follow.FieldUpdatedAt:
		return m.UpdatedAt()
	case follow.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case follow.FieldIsRemote:
		return m.OldIsRemote(ctx)
	case follow.FieldURI:
		return m.OldURI(ctx)
	case follow.FieldExtensions:
		return m.OldExtensions(ctx)
	case follow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case follow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case follow.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Follow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case follow.FieldIsRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemote(v)
		return nil
	case follow.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case follow.FieldExtensions:
		v, ok := value.(versia.Extensions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	case follow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case follow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case follow.FieldStatus:
		v, ok := value.(follow.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Follow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Follow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Follow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowMutation) ResetField(name string) error {
	switch name {
	case follow.FieldIsRemote:
		m.ResetIsRemote()
		return nil
	case follow.FieldURI:
		m.ResetURI()
		return nil
	case follow.FieldExtensions:
		m.ResetExtensions()
		return nil
	case follow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case follow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case follow.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Follow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, follow.EdgeFollower)
	}
	if m.followee != nil {
		edges = append(edges, follow.EdgeFollowee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case follow.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case follow.EdgeFollowee:
		if id := m.followee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, follow.EdgeFollower)
	}
	if m.clearedfollowee {
		edges = append(edges, follow.EdgeFollowee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowMutation) EdgeCleared(name string) bool {
	switch name {
	case follow.EdgeFollower:
		return m.clearedfollower
	case follow.EdgeFollowee:
		return m.clearedfollowee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowMutation) ClearEdge(name string) error {
	switch name {
	case follow.EdgeFollower:
		m.ClearFollower()
		return nil
	case follow.EdgeFollowee:
		m.ClearFollowee()
		return nil
	}
	return fmt.Errorf("unknown Follow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowMutation) ResetEdge(name string) error {
	switch name {
	case follow.EdgeFollower:
		m.ResetFollower()
		return nil
	case follow.EdgeFollowee:
		m.ResetFollowee()
		return nil
	}
	return fmt.Errorf("unknown Follow edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	url           *string
	mimeType      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id int) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *ImageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ImageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ImageMutation) ResetURL() {
	m.url = nil
}

// SetMimeType sets the "mimeType" field.
func (m *ImageMutation) SetMimeType(s string) {
	m.mimeType = &s
}

// MimeType returns the value of the "mimeType" field in the mutation.
func (m *ImageMutation) MimeType() (r string, exists bool) {
	v := m.mimeType
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mimeType" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mimeType" field.
func (m *ImageMutation) ResetMimeType() {
	m.mimeType = nil
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.url != nil {
		fields = append(fields, image.FieldURL)
	}
	if m.mimeType != nil {
		fields = append(fields, image.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldURL:
		return m.URL()
	case image.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldURL:
		return m.OldURL(ctx)
	case image.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case image.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldURL:
		m.ResetURL()
		return nil
	case image.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Image edge %s", name)
}

// InstanceMetadataMutation represents an operation that mutates the InstanceMetadata nodes in the graph.
type InstanceMetadataMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	isRemote                  *bool
	uri                       *string
	extensions                *versia.Extensions
	created_at                *time.Time
	updated_at                *time.Time
	name                      *string
	description               *string
	host                      *string
	publicKey                 *[]byte
	publicKeyAlgorithm        *string
	privateKey                *[]byte
	softwareName              *string
	softwareVersion           *string
	sharedInboxURI            *string
	moderatorsURI             *string
	adminsURI                 *string
	logoEndpoint              *string
	logoMimeType              *string
	bannerEndpoint            *string
	bannerMimeType            *string
	supportedVersions         *[]string
	appendsupportedVersions   []string
	supportedExtensions       *[]string
	appendsupportedExtensions []string
	clearedFields             map[string]struct{}
	users                     map[uuid.UUID]struct{}
	removedusers              map[uuid.UUID]struct{}
	clearedusers              bool
	moderators                map[uuid.UUID]struct{}
	removedmoderators         map[uuid.UUID]struct{}
	clearedmoderators         bool
	admins                    map[uuid.UUID]struct{}
	removedadmins             map[uuid.UUID]struct{}
	clearedadmins             bool
	done                      bool
	oldValue                  func(context.Context) (*InstanceMetadata, error)
	predicates                []predicate.InstanceMetadata
}

var _ ent.Mutation = (*InstanceMetadataMutation)(nil)

// instancemetadataOption allows management of the mutation configuration using functional options.
type instancemetadataOption func(*InstanceMetadataMutation)

// newInstanceMetadataMutation creates new mutation for the InstanceMetadata entity.
func newInstanceMetadataMutation(c config, op Op, opts ...instancemetadataOption) *InstanceMetadataMutation {
	m := &InstanceMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceMetadataID sets the ID field of the mutation.
func withInstanceMetadataID(id uuid.UUID) instancemetadataOption {
	return func(m *InstanceMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceMetadata
		)
		m.oldValue = func(ctx context.Context) (*InstanceMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceMetadata sets the old InstanceMetadata of the mutation.
func withInstanceMetadata(node *InstanceMetadata) instancemetadataOption {
	return func(m *InstanceMetadataMutation) {
		m.oldValue = func(context.Context) (*InstanceMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceMetadata entities.
func (m *InstanceMetadataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceMetadataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceMetadataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsRemote sets the "isRemote" field.
func (m *InstanceMetadataMutation) SetIsRemote(b bool) {
	m.isRemote = &b
}

// IsRemote returns the value of the "isRemote" field in the mutation.
func (m *InstanceMetadataMutation) IsRemote() (r bool, exists bool) {
	v := m.isRemote
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemote returns the old "isRemote" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldIsRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemote: %w", err)
	}
	return oldValue.IsRemote, nil
}

// ResetIsRemote resets all changes to the "isRemote" field.
func (m *InstanceMetadataMutation) ResetIsRemote() {
	m.isRemote = nil
}

// SetURI sets the "uri" field.
func (m *InstanceMetadataMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *InstanceMetadataMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *InstanceMetadataMutation) ResetURI() {
	m.uri = nil
}

// SetExtensions sets the "extensions" field.
func (m *InstanceMetadataMutation) SetExtensions(v versia.Extensions) {
	m.extensions = &v
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *InstanceMetadataMutation) Extensions() (r versia.Extensions, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldExtensions(ctx context.Context) (v versia.Extensions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *InstanceMetadataMutation) ResetExtensions() {
	m.extensions = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InstanceMetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstanceMetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstanceMetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstanceMetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstanceMetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstanceMetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *InstanceMetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InstanceMetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InstanceMetadataMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *InstanceMetadataMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InstanceMetadataMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InstanceMetadataMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[instancemetadata.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InstanceMetadataMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InstanceMetadataMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, instancemetadata.FieldDescription)
}

// SetHost sets the "host" field.
func (m *InstanceMetadataMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *InstanceMetadataMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *InstanceMetadataMutation) ResetHost() {
	m.host = nil
}

// SetPublicKey sets the "publicKey" field.
func (m *InstanceMetadataMutation) SetPublicKey(b []byte) {
	m.publicKey = &b
}

// PublicKey returns the value of the "publicKey" field in the mutation.
func (m *InstanceMetadataMutation) PublicKey() (r []byte, exists bool) {
	v := m.publicKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "publicKey" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "publicKey" field.
func (m *InstanceMetadataMutation) ResetPublicKey() {
	m.publicKey = nil
}

// SetPublicKeyAlgorithm sets the "publicKeyAlgorithm" field.
func (m *InstanceMetadataMutation) SetPublicKeyAlgorithm(s string) {
	m.publicKeyAlgorithm = &s
}

// PublicKeyAlgorithm returns the value of the "publicKeyAlgorithm" field in the mutation.
func (m *InstanceMetadataMutation) PublicKeyAlgorithm() (r string, exists bool) {
	v := m.publicKeyAlgorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeyAlgorithm returns the old "publicKeyAlgorithm" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldPublicKeyAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeyAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeyAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeyAlgorithm: %w", err)
	}
	return oldValue.PublicKeyAlgorithm, nil
}

// ResetPublicKeyAlgorithm resets all changes to the "publicKeyAlgorithm" field.
func (m *InstanceMetadataMutation) ResetPublicKeyAlgorithm() {
	m.publicKeyAlgorithm = nil
}

// SetPrivateKey sets the "privateKey" field.
func (m *InstanceMetadataMutation) SetPrivateKey(b []byte) {
	m.privateKey = &b
}

// PrivateKey returns the value of the "privateKey" field in the mutation.
func (m *InstanceMetadataMutation) PrivateKey() (r []byte, exists bool) {
	v := m.privateKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "privateKey" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldPrivateKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ClearPrivateKey clears the value of the "privateKey" field.
func (m *InstanceMetadataMutation) ClearPrivateKey() {
	m.privateKey = nil
	m.clearedFields[instancemetadata.FieldPrivateKey] = struct{}{}
}

// PrivateKeyCleared returns if the "privateKey" field was cleared in this mutation.
func (m *InstanceMetadataMutation) PrivateKeyCleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldPrivateKey]
	return ok
}

// ResetPrivateKey resets all changes to the "privateKey" field.
func (m *InstanceMetadataMutation) ResetPrivateKey() {
	m.privateKey = nil
	delete(m.clearedFields, instancemetadata.FieldPrivateKey)
}

// SetSoftwareName sets the "softwareName" field.
func (m *InstanceMetadataMutation) SetSoftwareName(s string) {
	m.softwareName = &s
}

// SoftwareName returns the value of the "softwareName" field in the mutation.
func (m *InstanceMetadataMutation) SoftwareName() (r string, exists bool) {
	v := m.softwareName
	if v == nil {
		return
	}
	return *v, true
}

// OldSoftwareName returns the old "softwareName" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldSoftwareName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoftwareName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoftwareName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoftwareName: %w", err)
	}
	return oldValue.SoftwareName, nil
}

// ResetSoftwareName resets all changes to the "softwareName" field.
func (m *InstanceMetadataMutation) ResetSoftwareName() {
	m.softwareName = nil
}

// SetSoftwareVersion sets the "softwareVersion" field.
func (m *InstanceMetadataMutation) SetSoftwareVersion(s string) {
	m.softwareVersion = &s
}

// SoftwareVersion returns the value of the "softwareVersion" field in the mutation.
func (m *InstanceMetadataMutation) SoftwareVersion() (r string, exists bool) {
	v := m.softwareVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldSoftwareVersion returns the old "softwareVersion" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldSoftwareVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoftwareVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoftwareVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoftwareVersion: %w", err)
	}
	return oldValue.SoftwareVersion, nil
}

// ResetSoftwareVersion resets all changes to the "softwareVersion" field.
func (m *InstanceMetadataMutation) ResetSoftwareVersion() {
	m.softwareVersion = nil
}

// SetSharedInboxURI sets the "sharedInboxURI" field.
func (m *InstanceMetadataMutation) SetSharedInboxURI(s string) {
	m.sharedInboxURI = &s
}

// SharedInboxURI returns the value of the "sharedInboxURI" field in the mutation.
func (m *InstanceMetadataMutation) SharedInboxURI() (r string, exists bool) {
	v := m.sharedInboxURI
	if v == nil {
		return
	}
	return *v, true
}

// OldSharedInboxURI returns the old "sharedInboxURI" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldSharedInboxURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharedInboxURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharedInboxURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharedInboxURI: %w", err)
	}
	return oldValue.SharedInboxURI, nil
}

// ResetSharedInboxURI resets all changes to the "sharedInboxURI" field.
func (m *InstanceMetadataMutation) ResetSharedInboxURI() {
	m.sharedInboxURI = nil
}

// SetModeratorsURI sets the "moderatorsURI" field.
func (m *InstanceMetadataMutation) SetModeratorsURI(s string) {
	m.moderatorsURI = &s
}

// ModeratorsURI returns the value of the "moderatorsURI" field in the mutation.
func (m *InstanceMetadataMutation) ModeratorsURI() (r string, exists bool) {
	v := m.moderatorsURI
	if v == nil {
		return
	}
	return *v, true
}

// OldModeratorsURI returns the old "moderatorsURI" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldModeratorsURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModeratorsURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModeratorsURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModeratorsURI: %w", err)
	}
	return oldValue.ModeratorsURI, nil
}

// ClearModeratorsURI clears the value of the "moderatorsURI" field.
func (m *InstanceMetadataMutation) ClearModeratorsURI() {
	m.moderatorsURI = nil
	m.clearedFields[instancemetadata.FieldModeratorsURI] = struct{}{}
}

// ModeratorsURICleared returns if the "moderatorsURI" field was cleared in this mutation.
func (m *InstanceMetadataMutation) ModeratorsURICleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldModeratorsURI]
	return ok
}

// ResetModeratorsURI resets all changes to the "moderatorsURI" field.
func (m *InstanceMetadataMutation) ResetModeratorsURI() {
	m.moderatorsURI = nil
	delete(m.clearedFields, instancemetadata.FieldModeratorsURI)
}

// SetAdminsURI sets the "adminsURI" field.
func (m *InstanceMetadataMutation) SetAdminsURI(s string) {
	m.adminsURI = &s
}

// AdminsURI returns the value of the "adminsURI" field in the mutation.
func (m *InstanceMetadataMutation) AdminsURI() (r string, exists bool) {
	v := m.adminsURI
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminsURI returns the old "adminsURI" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldAdminsURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminsURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminsURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminsURI: %w", err)
	}
	return oldValue.AdminsURI, nil
}

// ClearAdminsURI clears the value of the "adminsURI" field.
func (m *InstanceMetadataMutation) ClearAdminsURI() {
	m.adminsURI = nil
	m.clearedFields[instancemetadata.FieldAdminsURI] = struct{}{}
}

// AdminsURICleared returns if the "adminsURI" field was cleared in this mutation.
func (m *InstanceMetadataMutation) AdminsURICleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldAdminsURI]
	return ok
}

// ResetAdminsURI resets all changes to the "adminsURI" field.
func (m *InstanceMetadataMutation) ResetAdminsURI() {
	m.adminsURI = nil
	delete(m.clearedFields, instancemetadata.FieldAdminsURI)
}

// SetLogoEndpoint sets the "logoEndpoint" field.
func (m *InstanceMetadataMutation) SetLogoEndpoint(s string) {
	m.logoEndpoint = &s
}

// LogoEndpoint returns the value of the "logoEndpoint" field in the mutation.
func (m *InstanceMetadataMutation) LogoEndpoint() (r string, exists bool) {
	v := m.logoEndpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoEndpoint returns the old "logoEndpoint" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldLogoEndpoint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoEndpoint: %w", err)
	}
	return oldValue.LogoEndpoint, nil
}

// ClearLogoEndpoint clears the value of the "logoEndpoint" field.
func (m *InstanceMetadataMutation) ClearLogoEndpoint() {
	m.logoEndpoint = nil
	m.clearedFields[instancemetadata.FieldLogoEndpoint] = struct{}{}
}

// LogoEndpointCleared returns if the "logoEndpoint" field was cleared in this mutation.
func (m *InstanceMetadataMutation) LogoEndpointCleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldLogoEndpoint]
	return ok
}

// ResetLogoEndpoint resets all changes to the "logoEndpoint" field.
func (m *InstanceMetadataMutation) ResetLogoEndpoint() {
	m.logoEndpoint = nil
	delete(m.clearedFields, instancemetadata.FieldLogoEndpoint)
}

// SetLogoMimeType sets the "logoMimeType" field.
func (m *InstanceMetadataMutation) SetLogoMimeType(s string) {
	m.logoMimeType = &s
}

// LogoMimeType returns the value of the "logoMimeType" field in the mutation.
func (m *InstanceMetadataMutation) LogoMimeType() (r string, exists bool) {
	v := m.logoMimeType
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoMimeType returns the old "logoMimeType" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldLogoMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoMimeType: %w", err)
	}
	return oldValue.LogoMimeType, nil
}

// ClearLogoMimeType clears the value of the "logoMimeType" field.
func (m *InstanceMetadataMutation) ClearLogoMimeType() {
	m.logoMimeType = nil
	m.clearedFields[instancemetadata.FieldLogoMimeType] = struct{}{}
}

// LogoMimeTypeCleared returns if the "logoMimeType" field was cleared in this mutation.
func (m *InstanceMetadataMutation) LogoMimeTypeCleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldLogoMimeType]
	return ok
}

// ResetLogoMimeType resets all changes to the "logoMimeType" field.
func (m *InstanceMetadataMutation) ResetLogoMimeType() {
	m.logoMimeType = nil
	delete(m.clearedFields, instancemetadata.FieldLogoMimeType)
}

// SetBannerEndpoint sets the "bannerEndpoint" field.
func (m *InstanceMetadataMutation) SetBannerEndpoint(s string) {
	m.bannerEndpoint = &s
}

// BannerEndpoint returns the value of the "bannerEndpoint" field in the mutation.
func (m *InstanceMetadataMutation) BannerEndpoint() (r string, exists bool) {
	v := m.bannerEndpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerEndpoint returns the old "bannerEndpoint" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldBannerEndpoint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerEndpoint: %w", err)
	}
	return oldValue.BannerEndpoint, nil
}

// ClearBannerEndpoint clears the value of the "bannerEndpoint" field.
func (m *InstanceMetadataMutation) ClearBannerEndpoint() {
	m.bannerEndpoint = nil
	m.clearedFields[instancemetadata.FieldBannerEndpoint] = struct{}{}
}

// BannerEndpointCleared returns if the "bannerEndpoint" field was cleared in this mutation.
func (m *InstanceMetadataMutation) BannerEndpointCleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldBannerEndpoint]
	return ok
}

// ResetBannerEndpoint resets all changes to the "bannerEndpoint" field.
func (m *InstanceMetadataMutation) ResetBannerEndpoint() {
	m.bannerEndpoint = nil
	delete(m.clearedFields, instancemetadata.FieldBannerEndpoint)
}

// SetBannerMimeType sets the "bannerMimeType" field.
func (m *InstanceMetadataMutation) SetBannerMimeType(s string) {
	m.bannerMimeType = &s
}

// BannerMimeType returns the value of the "bannerMimeType" field in the mutation.
func (m *InstanceMetadataMutation) BannerMimeType() (r string, exists bool) {
	v := m.bannerMimeType
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerMimeType returns the old "bannerMimeType" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldBannerMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerMimeType: %w", err)
	}
	return oldValue.BannerMimeType, nil
}

// ClearBannerMimeType clears the value of the "bannerMimeType" field.
func (m *InstanceMetadataMutation) ClearBannerMimeType() {
	m.bannerMimeType = nil
	m.clearedFields[instancemetadata.FieldBannerMimeType] = struct{}{}
}

// BannerMimeTypeCleared returns if the "bannerMimeType" field was cleared in this mutation.
func (m *InstanceMetadataMutation) BannerMimeTypeCleared() bool {
	_, ok := m.clearedFields[instancemetadata.FieldBannerMimeType]
	return ok
}

// ResetBannerMimeType resets all changes to the "bannerMimeType" field.
func (m *InstanceMetadataMutation) ResetBannerMimeType() {
	m.bannerMimeType = nil
	delete(m.clearedFields, instancemetadata.FieldBannerMimeType)
}

// SetSupportedVersions sets the "supportedVersions" field.
func (m *InstanceMetadataMutation) SetSupportedVersions(s []string) {
	m.supportedVersions = &s
	m.appendsupportedVersions = nil
}

// SupportedVersions returns the value of the "supportedVersions" field in the mutation.
func (m *InstanceMetadataMutation) SupportedVersions() (r []string, exists bool) {
	v := m.supportedVersions
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedVersions returns the old "supportedVersions" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldSupportedVersions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedVersions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedVersions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedVersions: %w", err)
	}
	return oldValue.SupportedVersions, nil
}

// AppendSupportedVersions adds s to the "supportedVersions" field.
func (m *InstanceMetadataMutation) AppendSupportedVersions(s []string) {
	m.appendsupportedVersions = append(m.appendsupportedVersions, s...)
}

// AppendedSupportedVersions returns the list of values that were appended to the "supportedVersions" field in this mutation.
func (m *InstanceMetadataMutation) AppendedSupportedVersions() ([]string, bool) {
	if len(m.appendsupportedVersions) == 0 {
		return nil, false
	}
	return m.appendsupportedVersions, true
}

// ResetSupportedVersions resets all changes to the "supportedVersions" field.
func (m *InstanceMetadataMutation) ResetSupportedVersions() {
	m.supportedVersions = nil
	m.appendsupportedVersions = nil
}

// SetSupportedExtensions sets the "supportedExtensions" field.
func (m *InstanceMetadataMutation) SetSupportedExtensions(s []string) {
	m.supportedExtensions = &s
	m.appendsupportedExtensions = nil
}

// SupportedExtensions returns the value of the "supportedExtensions" field in the mutation.
func (m *InstanceMetadataMutation) SupportedExtensions() (r []string, exists bool) {
	v := m.supportedExtensions
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedExtensions returns the old "supportedExtensions" field's value of the InstanceMetadata entity.
// If the InstanceMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMetadataMutation) OldSupportedExtensions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedExtensions: %w", err)
	}
	return oldValue.SupportedExtensions, nil
}

// AppendSupportedExtensions adds s to the "supportedExtensions" field.
func (m *InstanceMetadataMutation) AppendSupportedExtensions(s []string) {
	m.appendsupportedExtensions = append(m.appendsupportedExtensions, s...)
}

// AppendedSupportedExtensions returns the list of values that were appended to the "supportedExtensions" field in this mutation.
func (m *InstanceMetadataMutation) AppendedSupportedExtensions() ([]string, bool) {
	if len(m.appendsupportedExtensions) == 0 {
		return nil, false
	}
	return m.appendsupportedExtensions, true
}

// ResetSupportedExtensions resets all changes to the "supportedExtensions" field.
func (m *InstanceMetadataMutation) ResetSupportedExtensions() {
	m.supportedExtensions = nil
	m.appendsupportedExtensions = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *InstanceMetadataMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *InstanceMetadataMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *InstanceMetadataMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *InstanceMetadataMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *InstanceMetadataMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *InstanceMetadataMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *InstanceMetadataMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddModeratorIDs adds the "moderators" edge to the User entity by ids.
func (m *InstanceMetadataMutation) AddModeratorIDs(ids ...uuid.UUID) {
	if m.moderators == nil {
		m.moderators = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.moderators[ids[i]] = struct{}{}
	}
}

// ClearModerators clears the "moderators" edge to the User entity.
func (m *InstanceMetadataMutation) ClearModerators() {
	m.clearedmoderators = true
}

// ModeratorsCleared reports if the "moderators" edge to the User entity was cleared.
func (m *InstanceMetadataMutation) ModeratorsCleared() bool {
	return m.clearedmoderators
}

// RemoveModeratorIDs removes the "moderators" edge to the User entity by IDs.
func (m *InstanceMetadataMutation) RemoveModeratorIDs(ids ...uuid.UUID) {
	if m.removedmoderators == nil {
		m.removedmoderators = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.moderators, ids[i])
		m.removedmoderators[ids[i]] = struct{}{}
	}
}

// RemovedModerators returns the removed IDs of the "moderators" edge to the User entity.
func (m *InstanceMetadataMutation) RemovedModeratorsIDs() (ids []uuid.UUID) {
	for id := range m.removedmoderators {
		ids = append(ids, id)
	}
	return
}

// ModeratorsIDs returns the "moderators" edge IDs in the mutation.
func (m *InstanceMetadataMutation) ModeratorsIDs() (ids []uuid.UUID) {
	for id := range m.moderators {
		ids = append(ids, id)
	}
	return
}

// ResetModerators resets all changes to the "moderators" edge.
func (m *InstanceMetadataMutation) ResetModerators() {
	m.moderators = nil
	m.clearedmoderators = false
	m.removedmoderators = nil
}

// AddAdminIDs adds the "admins" edge to the User entity by ids.
func (m *InstanceMetadataMutation) AddAdminIDs(ids ...uuid.UUID) {
	if m.admins == nil {
		m.admins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the User entity.
func (m *InstanceMetadataMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the User entity was cleared.
func (m *InstanceMetadataMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the User entity by IDs.
func (m *InstanceMetadataMutation) RemoveAdminIDs(ids ...uuid.UUID) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admins, ids[i])
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the User entity.
func (m *InstanceMetadataMutation) RemovedAdminsIDs() (ids []uuid.UUID) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *InstanceMetadataMutation) AdminsIDs() (ids []uuid.UUID) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *InstanceMetadataMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// Where appends a list predicates to the InstanceMetadataMutation builder.
func (m *InstanceMetadataMutation) Where(ps ...predicate.InstanceMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstanceMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstanceMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstanceMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstanceMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstanceMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstanceMetadata).
func (m *InstanceMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceMetadataMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.isRemote != nil {
		fields = append(fields, instancemetadata.FieldIsRemote)
	}
	if m.uri != nil {
		fields = append(fields, instancemetadata.FieldURI)
	}
	if m.extensions != nil {
		fields = append(fields, instancemetadata.FieldExtensions)
	}
	if m.created_at != nil {
		fields = append(fields, instancemetadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, instancemetadata.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, instancemetadata.FieldName)
	}
	if m.description != nil {
		fields = append(fields, instancemetadata.FieldDescription)
	}
	if m.host != nil {
		fields = append(fields, instancemetadata.FieldHost)
	}
	if m.publicKey != nil {
		fields = append(fields, instancemetadata.FieldPublicKey)
	}
	if m.publicKeyAlgorithm != nil {
		fields = append(fields, instancemetadata.FieldPublicKeyAlgorithm)
	}
	if m.privateKey != nil {
		fields = append(fields, instancemetadata.FieldPrivateKey)
	}
	if m.softwareName != nil {
		fields = append(fields, instancemetadata.FieldSoftwareName)
	}
	if m.softwareVersion != nil {
		fields = append(fields, instancemetadata.FieldSoftwareVersion)
	}
	if m.sharedInboxURI != nil {
		fields = append(fields, instancemetadata.FieldSharedInboxURI)
	}
	if m.moderatorsURI != nil {
		fields = append(fields, instancemetadata.FieldModeratorsURI)
	}
	if m.adminsURI != nil {
		fields = append(fields, instancemetadata.FieldAdminsURI)
	}
	if m.logoEndpoint != nil {
		fields = append(fields, instancemetadata.FieldLogoEndpoint)
	}
	if m.logoMimeType != nil {
		fields = append(fields, instancemetadata.FieldLogoMimeType)
	}
	if m.bannerEndpoint != nil {
		fields = append(fields, instancemetadata.FieldBannerEndpoint)
	}
	if m.bannerMimeType != nil {
		fields = append(fields, instancemetadata.FieldBannerMimeType)
	}
	if m.supportedVersions != nil {
		fields = append(fields, instancemetadata.FieldSupportedVersions)
	}
	if m.supportedExtensions != nil {
		fields = append(fields, instancemetadata.FieldSupportedExtensions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instancemetadata.FieldIsRemote:
		return m.IsRemote()
	case instancemetadata.FieldURI:
		return m.URI()
	case instancemetadata.FieldExtensions:
		return m.Extensions()
	case instancemetadata.FieldCreatedAt:
		return m.CreatedAt()
	case instancemetadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case instancemetadata.FieldName:
		return m.Name()
	case instancemetadata.FieldDescription:
		return m.Description()
	case instancemetadata.FieldHost:
		return m.Host()
	case instancemetadata.FieldPublicKey:
		return m.PublicKey()
	case instancemetadata.FieldPublicKeyAlgorithm:
		return m.PublicKeyAlgorithm()
	case instancemetadata.FieldPrivateKey:
		return m.PrivateKey()
	case instancemetadata.FieldSoftwareName:
		return m.SoftwareName()
	case instancemetadata.FieldSoftwareVersion:
		return m.SoftwareVersion()
	case instancemetadata.FieldSharedInboxURI:
		return m.SharedInboxURI()
	case instancemetadata.FieldModeratorsURI:
		return m.ModeratorsURI()
	case instancemetadata.FieldAdminsURI:
		return m.AdminsURI()
	case instancemetadata.FieldLogoEndpoint:
		return m.LogoEndpoint()
	case instancemetadata.FieldLogoMimeType:
		return m.LogoMimeType()
	case instancemetadata.FieldBannerEndpoint:
		return m.BannerEndpoint()
	case instancemetadata.FieldBannerMimeType:
		return m.BannerMimeType()
	case instancemetadata.FieldSupportedVersions:
		return m.SupportedVersions()
	case instancemetadata.FieldSupportedExtensions:
		return m.SupportedExtensions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instancemetadata.FieldIsRemote:
		return m.OldIsRemote(ctx)
	case instancemetadata.FieldURI:
		return m.OldURI(ctx)
	case instancemetadata.FieldExtensions:
		return m.OldExtensions(ctx)
	case instancemetadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case instancemetadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case instancemetadata.FieldName:
		return m.OldName(ctx)
	case instancemetadata.FieldDescription:
		return m.OldDescription(ctx)
	case instancemetadata.FieldHost:
		return m.OldHost(ctx)
	case instancemetadata.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case instancemetadata.FieldPublicKeyAlgorithm:
		return m.OldPublicKeyAlgorithm(ctx)
	case instancemetadata.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case instancemetadata.FieldSoftwareName:
		return m.OldSoftwareName(ctx)
	case instancemetadata.FieldSoftwareVersion:
		return m.OldSoftwareVersion(ctx)
	case instancemetadata.FieldSharedInboxURI:
		return m.OldSharedInboxURI(ctx)
	case instancemetadata.FieldModeratorsURI:
		return m.OldModeratorsURI(ctx)
	case instancemetadata.FieldAdminsURI:
		return m.OldAdminsURI(ctx)
	case instancemetadata.FieldLogoEndpoint:
		return m.OldLogoEndpoint(ctx)
	case instancemetadata.FieldLogoMimeType:
		return m.OldLogoMimeType(ctx)
	case instancemetadata.FieldBannerEndpoint:
		return m.OldBannerEndpoint(ctx)
	case instancemetadata.FieldBannerMimeType:
		return m.OldBannerMimeType(ctx)
	case instancemetadata.FieldSupportedVersions:
		return m.OldSupportedVersions(ctx)
	case instancemetadata.FieldSupportedExtensions:
		return m.OldSupportedExtensions(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instancemetadata.FieldIsRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemote(v)
		return nil
	case instancemetadata.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case instancemetadata.FieldExtensions:
		v, ok := value.(versia.Extensions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	case instancemetadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case instancemetadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case instancemetadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case instancemetadata.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case instancemetadata.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case instancemetadata.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case instancemetadata.FieldPublicKeyAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeyAlgorithm(v)
		return nil
	case instancemetadata.FieldPrivateKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case instancemetadata.FieldSoftwareName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoftwareName(v)
		return nil
	case instancemetadata.FieldSoftwareVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoftwareVersion(v)
		return nil
	case instancemetadata.FieldSharedInboxURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharedInboxURI(v)
		return nil
	case instancemetadata.FieldModeratorsURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModeratorsURI(v)
		return nil
	case instancemetadata.FieldAdminsURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminsURI(v)
		return nil
	case instancemetadata.FieldLogoEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoEndpoint(v)
		return nil
	case instancemetadata.FieldLogoMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoMimeType(v)
		return nil
	case instancemetadata.FieldBannerEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerEndpoint(v)
		return nil
	case instancemetadata.FieldBannerMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerMimeType(v)
		return nil
	case instancemetadata.FieldSupportedVersions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedVersions(v)
		return nil
	case instancemetadata.FieldSupportedExtensions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedExtensions(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceMetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceMetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstanceMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instancemetadata.FieldDescription) {
		fields = append(fields, instancemetadata.FieldDescription)
	}
	if m.FieldCleared(instancemetadata.FieldPrivateKey) {
		fields = append(fields, instancemetadata.FieldPrivateKey)
	}
	if m.FieldCleared(instancemetadata.FieldModeratorsURI) {
		fields = append(fields, instancemetadata.FieldModeratorsURI)
	}
	if m.FieldCleared(instancemetadata.FieldAdminsURI) {
		fields = append(fields, instancemetadata.FieldAdminsURI)
	}
	if m.FieldCleared(instancemetadata.FieldLogoEndpoint) {
		fields = append(fields, instancemetadata.FieldLogoEndpoint)
	}
	if m.FieldCleared(instancemetadata.FieldLogoMimeType) {
		fields = append(fields, instancemetadata.FieldLogoMimeType)
	}
	if m.FieldCleared(instancemetadata.FieldBannerEndpoint) {
		fields = append(fields, instancemetadata.FieldBannerEndpoint)
	}
	if m.FieldCleared(instancemetadata.FieldBannerMimeType) {
		fields = append(fields, instancemetadata.FieldBannerMimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceMetadataMutation) ClearField(name string) error {
	switch name {
	case instancemetadata.FieldDescription:
		m.ClearDescription()
		return nil
	case instancemetadata.FieldPrivateKey:
		m.ClearPrivateKey()
		return nil
	case instancemetadata.FieldModeratorsURI:
		m.ClearModeratorsURI()
		return nil
	case instancemetadata.FieldAdminsURI:
		m.ClearAdminsURI()
		return nil
	case instancemetadata.FieldLogoEndpoint:
		m.ClearLogoEndpoint()
		return nil
	case instancemetadata.FieldLogoMimeType:
		m.ClearLogoMimeType()
		return nil
	case instancemetadata.FieldBannerEndpoint:
		m.ClearBannerEndpoint()
		return nil
	case instancemetadata.FieldBannerMimeType:
		m.ClearBannerMimeType()
		return nil
	}
	return fmt.Errorf("unknown InstanceMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceMetadataMutation) ResetField(name string) error {
	switch name {
	case instancemetadata.FieldIsRemote:
		m.ResetIsRemote()
		return nil
	case instancemetadata.FieldURI:
		m.ResetURI()
		return nil
	case instancemetadata.FieldExtensions:
		m.ResetExtensions()
		return nil
	case instancemetadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case instancemetadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case instancemetadata.FieldName:
		m.ResetName()
		return nil
	case instancemetadata.FieldDescription:
		m.ResetDescription()
		return nil
	case instancemetadata.FieldHost:
		m.ResetHost()
		return nil
	case instancemetadata.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case instancemetadata.FieldPublicKeyAlgorithm:
		m.ResetPublicKeyAlgorithm()
		return nil
	case instancemetadata.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case instancemetadata.FieldSoftwareName:
		m.ResetSoftwareName()
		return nil
	case instancemetadata.FieldSoftwareVersion:
		m.ResetSoftwareVersion()
		return nil
	case instancemetadata.FieldSharedInboxURI:
		m.ResetSharedInboxURI()
		return nil
	case instancemetadata.FieldModeratorsURI:
		m.ResetModeratorsURI()
		return nil
	case instancemetadata.FieldAdminsURI:
		m.ResetAdminsURI()
		return nil
	case instancemetadata.FieldLogoEndpoint:
		m.ResetLogoEndpoint()
		return nil
	case instancemetadata.FieldLogoMimeType:
		m.ResetLogoMimeType()
		return nil
	case instancemetadata.FieldBannerEndpoint:
		m.ResetBannerEndpoint()
		return nil
	case instancemetadata.FieldBannerMimeType:
		m.ResetBannerMimeType()
		return nil
	case instancemetadata.FieldSupportedVersions:
		m.ResetSupportedVersions()
		return nil
	case instancemetadata.FieldSupportedExtensions:
		m.ResetSupportedExtensions()
		return nil
	}
	return fmt.Errorf("unknown InstanceMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, instancemetadata.EdgeUsers)
	}
	if m.moderators != nil {
		edges = append(edges, instancemetadata.EdgeModerators)
	}
	if m.admins != nil {
		edges = append(edges, instancemetadata.EdgeAdmins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instancemetadata.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case instancemetadata.EdgeModerators:
		ids := make([]ent.Value, 0, len(m.moderators))
		for id := range m.moderators {
			ids = append(ids, id)
		}
		return ids
	case instancemetadata.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, instancemetadata.EdgeUsers)
	}
	if m.removedmoderators != nil {
		edges = append(edges, instancemetadata.EdgeModerators)
	}
	if m.removedadmins != nil {
		edges = append(edges, instancemetadata.EdgeAdmins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceMetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instancemetadata.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case instancemetadata.EdgeModerators:
		ids := make([]ent.Value, 0, len(m.removedmoderators))
		for id := range m.removedmoderators {
			ids = append(ids, id)
		}
		return ids
	case instancemetadata.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, instancemetadata.EdgeUsers)
	}
	if m.clearedmoderators {
		edges = append(edges, instancemetadata.EdgeModerators)
	}
	if m.clearedadmins {
		edges = append(edges, instancemetadata.EdgeAdmins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case instancemetadata.EdgeUsers:
		return m.clearedusers
	case instancemetadata.EdgeModerators:
		return m.clearedmoderators
	case instancemetadata.EdgeAdmins:
		return m.clearedadmins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceMetadataMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InstanceMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceMetadataMutation) ResetEdge(name string) error {
	switch name {
	case instancemetadata.EdgeUsers:
		m.ResetUsers()
		return nil
	case instancemetadata.EdgeModerators:
		m.ResetModerators()
		return nil
	case instancemetadata.EdgeAdmins:
		m.ResetAdmins()
		return nil
	}
	return fmt.Errorf("unknown InstanceMetadata edge %s", name)
}

// NoteMutation represents an operation that mutates the Note nodes in the graph.
type NoteMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	isRemote           *bool
	uri                *string
	extensions         *versia.Extensions
	created_at         *time.Time
	updated_at         *time.Time
	subject            *string
	content            *string
	isSensitive        *bool
	visibility         *note.Visibility
	clearedFields      map[string]struct{}
	author             *uuid.UUID
	clearedauthor      bool
	mentions           map[uuid.UUID]struct{}
	removedmentions    map[uuid.UUID]struct{}
	clearedmentions    bool
	attachments        map[uuid.UUID]struct{}
	removedattachments map[uuid.UUID]struct{}
	clearedattachments bool
	done               bool
	oldValue           func(context.Context) (*Note, error)
	predicates         []predicate.Note
}

var _ ent.Mutation = (*NoteMutation)(nil)

// noteOption allows management of the mutation configuration using functional options.
type noteOption func(*NoteMutation)

// newNoteMutation creates new mutation for the Note entity.
func newNoteMutation(c config, op Op, opts ...noteOption) *NoteMutation {
	m := &NoteMutation{
		config:        c,
		op:            op,
		typ:           TypeNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoteID sets the ID field of the mutation.
func withNoteID(id uuid.UUID) noteOption {
	return func(m *NoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Note
		)
		m.oldValue = func(ctx context.Context) (*Note, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Note.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNote sets the old Note of the mutation.
func withNote(node *Note) noteOption {
	return func(m *NoteMutation) {
		m.oldValue = func(context.Context) (*Note, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Note entities.
func (m *NoteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Note.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsRemote sets the "isRemote" field.
func (m *NoteMutation) SetIsRemote(b bool) {
	m.isRemote = &b
}

// IsRemote returns the value of the "isRemote" field in the mutation.
func (m *NoteMutation) IsRemote() (r bool, exists bool) {
	v := m.isRemote
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemote returns the old "isRemote" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldIsRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemote: %w", err)
	}
	return oldValue.IsRemote, nil
}

// ResetIsRemote resets all changes to the "isRemote" field.
func (m *NoteMutation) ResetIsRemote() {
	m.isRemote = nil
}

// SetURI sets the "uri" field.
func (m *NoteMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *NoteMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *NoteMutation) ResetURI() {
	m.uri = nil
}

// SetExtensions sets the "extensions" field.
func (m *NoteMutation) SetExtensions(v versia.Extensions) {
	m.extensions = &v
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *NoteMutation) Extensions() (r versia.Extensions, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldExtensions(ctx context.Context) (v versia.Extensions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *NoteMutation) ResetExtensions() {
	m.extensions = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSubject sets the "subject" field.
func (m *NoteMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *NoteMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldSubject(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ClearSubject clears the value of the "subject" field.
func (m *NoteMutation) ClearSubject() {
	m.subject = nil
	m.clearedFields[note.FieldSubject] = struct{}{}
}

// SubjectCleared returns if the "subject" field was cleared in this mutation.
func (m *NoteMutation) SubjectCleared() bool {
	_, ok := m.clearedFields[note.FieldSubject]
	return ok
}

// ResetSubject resets all changes to the "subject" field.
func (m *NoteMutation) ResetSubject() {
	m.subject = nil
	delete(m.clearedFields, note.FieldSubject)
}

// SetContent sets the "content" field.
func (m *NoteMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NoteMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *NoteMutation) ResetContent() {
	m.content = nil
}

// SetIsSensitive sets the "isSensitive" field.
func (m *NoteMutation) SetIsSensitive(b bool) {
	m.isSensitive = &b
}

// IsSensitive returns the value of the "isSensitive" field in the mutation.
func (m *NoteMutation) IsSensitive() (r bool, exists bool) {
	v := m.isSensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSensitive returns the old "isSensitive" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldIsSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSensitive: %w", err)
	}
	return oldValue.IsSensitive, nil
}

// ResetIsSensitive resets all changes to the "isSensitive" field.
func (m *NoteMutation) ResetIsSensitive() {
	m.isSensitive = nil
}

// SetVisibility sets the "visibility" field.
func (m *NoteMutation) SetVisibility(n note.Visibility) {
	m.visibility = &n
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *NoteMutation) Visibility() (r note.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldVisibility(ctx context.Context) (v note.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *NoteMutation) ResetVisibility() {
	m.visibility = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *NoteMutation) SetAuthorID(id uuid.UUID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *NoteMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *NoteMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *NoteMutation) AuthorID() (id uuid.UUID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *NoteMutation) AuthorIDs() (ids []uuid.UUID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *NoteMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddMentionIDs adds the "mentions" edge to the User entity by ids.
func (m *NoteMutation) AddMentionIDs(ids ...uuid.UUID) {
	if m.mentions == nil {
		m.mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mentions[ids[i]] = struct{}{}
	}
}

// ClearMentions clears the "mentions" edge to the User entity.
func (m *NoteMutation) ClearMentions() {
	m.clearedmentions = true
}

// MentionsCleared reports if the "mentions" edge to the User entity was cleared.
func (m *NoteMutation) MentionsCleared() bool {
	return m.clearedmentions
}

// RemoveMentionIDs removes the "mentions" edge to the User entity by IDs.
func (m *NoteMutation) RemoveMentionIDs(ids ...uuid.UUID) {
	if m.removedmentions == nil {
		m.removedmentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mentions, ids[i])
		m.removedmentions[ids[i]] = struct{}{}
	}
}

// RemovedMentions returns the removed IDs of the "mentions" edge to the User entity.
func (m *NoteMutation) RemovedMentionsIDs() (ids []uuid.UUID) {
	for id := range m.removedmentions {
		ids = append(ids, id)
	}
	return
}

// MentionsIDs returns the "mentions" edge IDs in the mutation.
func (m *NoteMutation) MentionsIDs() (ids []uuid.UUID) {
	for id := range m.mentions {
		ids = append(ids, id)
	}
	return
}

// ResetMentions resets all changes to the "mentions" edge.
func (m *NoteMutation) ResetMentions() {
	m.mentions = nil
	m.clearedmentions = false
	m.removedmentions = nil
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *NoteMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *NoteMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *NoteMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *NoteMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *NoteMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *NoteMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *NoteMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Where appends a list predicates to the NoteMutation builder.
func (m *NoteMutation) Where(ps ...predicate.Note) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Note, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Note).
func (m *NoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoteMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.isRemote != nil {
		fields = append(fields, note.FieldIsRemote)
	}
	if m.uri != nil {
		fields = append(fields, note.FieldURI)
	}
	if m.extensions != nil {
		fields = append(fields, note.FieldExtensions)
	}
	if m.created_at != nil {
		fields = append(fields, note.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, note.FieldUpdatedAt)
	}
	if m.subject != nil {
		fields = append(fields, note.FieldSubject)
	}
	if m.content != nil {
		fields = append(fields, note.FieldContent)
	}
	if m.isSensitive != nil {
		fields = append(fields, note.FieldIsSensitive)
	}
	if m.visibility != nil {
		fields = append(fields, note.FieldVisibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case note.FieldIsRemote:
		return m.IsRemote()
	case note.FieldURI:
		return m.URI()
	case note.FieldExtensions:
		return m.Extensions()
	case note.FieldCreatedAt:
		return m.CreatedAt()
	case note.FieldUpdatedAt:
		return m.UpdatedAt()
	case note.FieldSubject:
		return m.Subject()
	case note.FieldContent:
		return m.Content()
	case note.FieldIsSensitive:
		return m.IsSensitive()
	case note.FieldVisibility:
		return m.Visibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case note.FieldIsRemote:
		return m.OldIsRemote(ctx)
	case note.FieldURI:
		return m.OldURI(ctx)
	case note.FieldExtensions:
		return m.OldExtensions(ctx)
	case note.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case note.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case note.FieldSubject:
		return m.OldSubject(ctx)
	case note.FieldContent:
		return m.OldContent(ctx)
	case note.FieldIsSensitive:
		return m.OldIsSensitive(ctx)
	case note.FieldVisibility:
		return m.OldVisibility(ctx)
	}
	return nil, fmt.Errorf("unknown Note field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case note.FieldIsRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemote(v)
		return nil
	case note.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case note.FieldExtensions:
		v, ok := value.(versia.Extensions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	case note.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case note.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case note.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case note.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case note.FieldIsSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSensitive(v)
		return nil
	case note.FieldVisibility:
		v, ok := value.(note.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	}
	return fmt.Errorf("unknown Note field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Note numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(note.FieldSubject) {
		fields = append(fields, note.FieldSubject)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoteMutation) ClearField(name string) error {
	switch name {
	case note.FieldSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown Note nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoteMutation) ResetField(name string) error {
	switch name {
	case note.FieldIsRemote:
		m.ResetIsRemote()
		return nil
	case note.FieldURI:
		m.ResetURI()
		return nil
	case note.FieldExtensions:
		m.ResetExtensions()
		return nil
	case note.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case note.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case note.FieldSubject:
		m.ResetSubject()
		return nil
	case note.FieldContent:
		m.ResetContent()
		return nil
	case note.FieldIsSensitive:
		m.ResetIsSensitive()
		return nil
	case note.FieldVisibility:
		m.ResetVisibility()
		return nil
	}
	return fmt.Errorf("unknown Note field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, note.EdgeAuthor)
	}
	if m.mentions != nil {
		edges = append(edges, note.EdgeMentions)
	}
	if m.attachments != nil {
		edges = append(edges, note.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case note.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case note.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.mentions))
		for id := range m.mentions {
			ids = append(ids, id)
		}
		return ids
	case note.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmentions != nil {
		edges = append(edges, note.EdgeMentions)
	}
	if m.removedattachments != nil {
		edges = append(edges, note.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case note.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.removedmentions))
		for id := range m.removedmentions {
			ids = append(ids, id)
		}
		return ids
	case note.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, note.EdgeAuthor)
	}
	if m.clearedmentions {
		edges = append(edges, note.EdgeMentions)
	}
	if m.clearedattachments {
		edges = append(edges, note.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoteMutation) EdgeCleared(name string) bool {
	switch name {
	case note.EdgeAuthor:
		return m.clearedauthor
	case note.EdgeMentions:
		return m.clearedmentions
	case note.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoteMutation) ClearEdge(name string) error {
	switch name {
	case note.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Note unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoteMutation) ResetEdge(name string) error {
	switch name {
	case note.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case note.EdgeMentions:
		m.ResetMentions()
		return nil
	case note.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Note edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	isRemote                   *bool
	uri                        *string
	extensions                 *versia.Extensions
	created_at                 *time.Time
	updated_at                 *time.Time
	username                   *string
	passwordHash               *[]byte
	displayName                *string
	biography                  *string
	publicKey                  *[]byte
	publicKeyActor             *string
	publicKeyAlgorithm         *string
	privateKey                 *[]byte
	indexable                  *bool
	privacyLevel               *user.PrivacyLevel
	fields                     *[]versia.UserField
	appendfields               []versia.UserField
	inbox                      *string
	featured                   *string
	followers                  *string
	following                  *string
	outbox                     *string
	clearedFields              map[string]struct{}
	avatarImage                *int
	clearedavatarImage         bool
	headerImage                *int
	clearedheaderImage         bool
	authoredNotes              map[uuid.UUID]struct{}
	removedauthoredNotes       map[uuid.UUID]struct{}
	clearedauthoredNotes       bool
	mentionedNotes             map[uuid.UUID]struct{}
	removedmentionedNotes      map[uuid.UUID]struct{}
	clearedmentionedNotes      bool
	servers                    map[uuid.UUID]struct{}
	removedservers             map[uuid.UUID]struct{}
	clearedservers             bool
	moderatedServers           map[uuid.UUID]struct{}
	removedmoderatedServers    map[uuid.UUID]struct{}
	clearedmoderatedServers    bool
	administeredServers        map[uuid.UUID]struct{}
	removedadministeredServers map[uuid.UUID]struct{}
	clearedadministeredServers bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsRemote sets the "isRemote" field.
func (m *UserMutation) SetIsRemote(b bool) {
	m.isRemote = &b
}

// IsRemote returns the value of the "isRemote" field in the mutation.
func (m *UserMutation) IsRemote() (r bool, exists bool) {
	v := m.isRemote
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemote returns the old "isRemote" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemote: %w", err)
	}
	return oldValue.IsRemote, nil
}

// ResetIsRemote resets all changes to the "isRemote" field.
func (m *UserMutation) ResetIsRemote() {
	m.isRemote = nil
}

// SetURI sets the "uri" field.
func (m *UserMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *UserMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *UserMutation) ResetURI() {
	m.uri = nil
}

// SetExtensions sets the "extensions" field.
func (m *UserMutation) SetExtensions(v versia.Extensions) {
	m.extensions = &v
}

// Extensions returns the value of the "extensions" field in the mutation.
func (m *UserMutation) Extensions() (r versia.Extensions, exists bool) {
	v := m.extensions
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensions returns the old "extensions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExtensions(ctx context.Context) (v versia.Extensions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensions: %w", err)
	}
	return oldValue.Extensions, nil
}

// ResetExtensions resets all changes to the "extensions" field.
func (m *UserMutation) ResetExtensions() {
	m.extensions = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "passwordHash" field.
func (m *UserMutation) SetPasswordHash(b []byte) {
	m.passwordHash = &b
}

// PasswordHash returns the value of the "passwordHash" field in the mutation.
func (m *UserMutation) PasswordHash() (r []byte, exists bool) {
	v := m.passwordHash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "passwordHash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "passwordHash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.passwordHash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "passwordHash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "passwordHash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.passwordHash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetDisplayName sets the "displayName" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.displayName = &s
}

// DisplayName returns the value of the "displayName" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.displayName
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "displayName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "displayName" field.
func (m *UserMutation) ClearDisplayName() {
	m.displayName = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "displayName" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "displayName" field.
func (m *UserMutation) ResetDisplayName() {
	m.displayName = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetBiography sets the "biography" field.
func (m *UserMutation) SetBiography(s string) {
	m.biography = &s
}

// Biography returns the value of the "biography" field in the mutation.
func (m *UserMutation) Biography() (r string, exists bool) {
	v := m.biography
	if v == nil {
		return
	}
	return *v, true
}

// OldBiography returns the old "biography" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBiography(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiography is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiography requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiography: %w", err)
	}
	return oldValue.Biography, nil
}

// ClearBiography clears the value of the "biography" field.
func (m *UserMutation) ClearBiography() {
	m.biography = nil
	m.clearedFields[user.FieldBiography] = struct{}{}
}

// BiographyCleared returns if the "biography" field was cleared in this mutation.
func (m *UserMutation) BiographyCleared() bool {
	_, ok := m.clearedFields[user.FieldBiography]
	return ok
}

// ResetBiography resets all changes to the "biography" field.
func (m *UserMutation) ResetBiography() {
	m.biography = nil
	delete(m.clearedFields, user.FieldBiography)
}

// SetPublicKey sets the "publicKey" field.
func (m *UserMutation) SetPublicKey(b []byte) {
	m.publicKey = &b
}

// PublicKey returns the value of the "publicKey" field in the mutation.
func (m *UserMutation) PublicKey() (r []byte, exists bool) {
	v := m.publicKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "publicKey" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "publicKey" field.
func (m *UserMutation) ResetPublicKey() {
	m.publicKey = nil
}

// SetPublicKeyActor sets the "publicKeyActor" field.
func (m *UserMutation) SetPublicKeyActor(s string) {
	m.publicKeyActor = &s
}

// PublicKeyActor returns the value of the "publicKeyActor" field in the mutation.
func (m *UserMutation) PublicKeyActor() (r string, exists bool) {
	v := m.publicKeyActor
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeyActor returns the old "publicKeyActor" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicKeyActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeyActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeyActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeyActor: %w", err)
	}
	return oldValue.PublicKeyActor, nil
}

// ResetPublicKeyActor resets all changes to the "publicKeyActor" field.
func (m *UserMutation) ResetPublicKeyActor() {
	m.publicKeyActor = nil
}

// SetPublicKeyAlgorithm sets the "publicKeyAlgorithm" field.
func (m *UserMutation) SetPublicKeyAlgorithm(s string) {
	m.publicKeyAlgorithm = &s
}

// PublicKeyAlgorithm returns the value of the "publicKeyAlgorithm" field in the mutation.
func (m *UserMutation) PublicKeyAlgorithm() (r string, exists bool) {
	v := m.publicKeyAlgorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKeyAlgorithm returns the old "publicKeyAlgorithm" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicKeyAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKeyAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKeyAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKeyAlgorithm: %w", err)
	}
	return oldValue.PublicKeyAlgorithm, nil
}

// ResetPublicKeyAlgorithm resets all changes to the "publicKeyAlgorithm" field.
func (m *UserMutation) ResetPublicKeyAlgorithm() {
	m.publicKeyAlgorithm = nil
}

// SetPrivateKey sets the "privateKey" field.
func (m *UserMutation) SetPrivateKey(b []byte) {
	m.privateKey = &b
}

// PrivateKey returns the value of the "privateKey" field in the mutation.
func (m *UserMutation) PrivateKey() (r []byte, exists bool) {
	v := m.privateKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "privateKey" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrivateKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ClearPrivateKey clears the value of the "privateKey" field.
func (m *UserMutation) ClearPrivateKey() {
	m.privateKey = nil
	m.clearedFields[user.FieldPrivateKey] = struct{}{}
}

// PrivateKeyCleared returns if the "privateKey" field was cleared in this mutation.
func (m *UserMutation) PrivateKeyCleared() bool {
	_, ok := m.clearedFields[user.FieldPrivateKey]
	return ok
}

// ResetPrivateKey resets all changes to the "privateKey" field.
func (m *UserMutation) ResetPrivateKey() {
	m.privateKey = nil
	delete(m.clearedFields, user.FieldPrivateKey)
}

// SetIndexable sets the "indexable" field.
func (m *UserMutation) SetIndexable(b bool) {
	m.indexable = &b
}

// Indexable returns the value of the "indexable" field in the mutation.
func (m *UserMutation) Indexable() (r bool, exists bool) {
	v := m.indexable
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexable returns the old "indexable" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIndexable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexable: %w", err)
	}
	return oldValue.Indexable, nil
}

// ResetIndexable resets all changes to the "indexable" field.
func (m *UserMutation) ResetIndexable() {
	m.indexable = nil
}

// SetPrivacyLevel sets the "privacyLevel" field.
func (m *UserMutation) SetPrivacyLevel(ul user.PrivacyLevel) {
	m.privacyLevel = &ul
}

// PrivacyLevel returns the value of the "privacyLevel" field in the mutation.
func (m *UserMutation) PrivacyLevel() (r user.PrivacyLevel, exists bool) {
	v := m.privacyLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivacyLevel returns the old "privacyLevel" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrivacyLevel(ctx context.Context) (v user.PrivacyLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivacyLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivacyLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivacyLevel: %w", err)
	}
	return oldValue.PrivacyLevel, nil
}

// ResetPrivacyLevel resets all changes to the "privacyLevel" field.
func (m *UserMutation) ResetPrivacyLevel() {
	m.privacyLevel = nil
}

// SetFields sets the "fields" field.
func (m *UserMutation) SetFields(vf []versia.UserField) {
	m.fields = &vf
	m.appendfields = nil
}

// GetFields returns the value of the "fields" field in the mutation.
func (m *UserMutation) GetFields() (r []versia.UserField, exists bool) {
	v := m.fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "fields" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFields(ctx context.Context) (v []versia.UserField, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// AppendFields adds vf to the "fields" field.
func (m *UserMutation) AppendFields(vf []versia.UserField) {
	m.appendfields = append(m.appendfields, vf...)
}

// AppendedFields returns the list of values that were appended to the "fields" field in this mutation.
func (m *UserMutation) AppendedFields() ([]versia.UserField, bool) {
	if len(m.appendfields) == 0 {
		return nil, false
	}
	return m.appendfields, true
}

// ResetFields resets all changes to the "fields" field.
func (m *UserMutation) ResetFields() {
	m.fields = nil
	m.appendfields = nil
}

// SetInbox sets the "inbox" field.
func (m *UserMutation) SetInbox(s string) {
	m.inbox = &s
}

// Inbox returns the value of the "inbox" field in the mutation.
func (m *UserMutation) Inbox() (r string, exists bool) {
	v := m.inbox
	if v == nil {
		return
	}
	return *v, true
}

// OldInbox returns the old "inbox" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldInbox(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInbox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInbox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInbox: %w", err)
	}
	return oldValue.Inbox, nil
}

// ResetInbox resets all changes to the "inbox" field.
func (m *UserMutation) ResetInbox() {
	m.inbox = nil
}

// SetFeatured sets the "featured" field.
func (m *UserMutation) SetFeatured(s string) {
	m.featured = &s
}

// Featured returns the value of the "featured" field in the mutation.
func (m *UserMutation) Featured() (r string, exists bool) {
	v := m.featured
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatured returns the old "featured" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFeatured(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatured: %w", err)
	}
	return oldValue.Featured, nil
}

// ResetFeatured resets all changes to the "featured" field.
func (m *UserMutation) ResetFeatured() {
	m.featured = nil
}

// SetFollowers sets the "followers" field.
func (m *UserMutation) SetFollowers(s string) {
	m.followers = &s
}

// Followers returns the value of the "followers" field in the mutation.
func (m *UserMutation) Followers() (r string, exists bool) {
	v := m.followers
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowers returns the old "followers" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowers: %w", err)
	}
	return oldValue.Followers, nil
}

// ResetFollowers resets all changes to the "followers" field.
func (m *UserMutation) ResetFollowers() {
	m.followers = nil
}

// SetFollowing sets the "following" field.
func (m *UserMutation) SetFollowing(s string) {
	m.following = &s
}

// Following returns the value of the "following" field in the mutation.
func (m *UserMutation) Following() (r string, exists bool) {
	v := m.following
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowing returns the old "following" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowing(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowing: %w", err)
	}
	return oldValue.Following, nil
}

// ResetFollowing resets all changes to the "following" field.
func (m *UserMutation) ResetFollowing() {
	m.following = nil
}

// SetOutbox sets the "outbox" field.
func (m *UserMutation) SetOutbox(s string) {
	m.outbox = &s
}

// Outbox returns the value of the "outbox" field in the mutation.
func (m *UserMutation) Outbox() (r string, exists bool) {
	v := m.outbox
	if v == nil {
		return
	}
	return *v, true
}

// OldOutbox returns the old "outbox" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOutbox(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutbox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutbox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutbox: %w", err)
	}
	return oldValue.Outbox, nil
}

// ResetOutbox resets all changes to the "outbox" field.
func (m *UserMutation) ResetOutbox() {
	m.outbox = nil
}

// SetAvatarImageID sets the "avatarImage" edge to the Image entity by id.
func (m *UserMutation) SetAvatarImageID(id int) {
	m.avatarImage = &id
}

// ClearAvatarImage clears the "avatarImage" edge to the Image entity.
func (m *UserMutation) ClearAvatarImage() {
	m.clearedavatarImage = true
}

// AvatarImageCleared reports if the "avatarImage" edge to the Image entity was cleared.
func (m *UserMutation) AvatarImageCleared() bool {
	return m.clearedavatarImage
}

// AvatarImageID returns the "avatarImage" edge ID in the mutation.
func (m *UserMutation) AvatarImageID() (id int, exists bool) {
	if m.avatarImage != nil {
		return *m.avatarImage, true
	}
	return
}

// AvatarImageIDs returns the "avatarImage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AvatarImageID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AvatarImageIDs() (ids []int) {
	if id := m.avatarImage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAvatarImage resets all changes to the "avatarImage" edge.
func (m *UserMutation) ResetAvatarImage() {
	m.avatarImage = nil
	m.clearedavatarImage = false
}

// SetHeaderImageID sets the "headerImage" edge to the Image entity by id.
func (m *UserMutation) SetHeaderImageID(id int) {
	m.headerImage = &id
}

// ClearHeaderImage clears the "headerImage" edge to the Image entity.
func (m *UserMutation) ClearHeaderImage() {
	m.clearedheaderImage = true
}

// HeaderImageCleared reports if the "headerImage" edge to the Image entity was cleared.
func (m *UserMutation) HeaderImageCleared() bool {
	return m.clearedheaderImage
}

// HeaderImageID returns the "headerImage" edge ID in the mutation.
func (m *UserMutation) HeaderImageID() (id int, exists bool) {
	if m.headerImage != nil {
		return *m.headerImage, true
	}
	return
}

// HeaderImageIDs returns the "headerImage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeaderImageID instead. It exists only for internal usage by the builders.
func (m *UserMutation) HeaderImageIDs() (ids []int) {
	if id := m.headerImage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHeaderImage resets all changes to the "headerImage" edge.
func (m *UserMutation) ResetHeaderImage() {
	m.headerImage = nil
	m.clearedheaderImage = false
}

// AddAuthoredNoteIDs adds the "authoredNotes" edge to the Note entity by ids.
func (m *UserMutation) AddAuthoredNoteIDs(ids ...uuid.UUID) {
	if m.authoredNotes == nil {
		m.authoredNotes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.authoredNotes[ids[i]] = struct{}{}
	}
}

// ClearAuthoredNotes clears the "authoredNotes" edge to the Note entity.
func (m *UserMutation) ClearAuthoredNotes() {
	m.clearedauthoredNotes = true
}

// AuthoredNotesCleared reports if the "authoredNotes" edge to the Note entity was cleared.
func (m *UserMutation) AuthoredNotesCleared() bool {
	return m.clearedauthoredNotes
}

// RemoveAuthoredNoteIDs removes the "authoredNotes" edge to the Note entity by IDs.
func (m *UserMutation) RemoveAuthoredNoteIDs(ids ...uuid.UUID) {
	if m.removedauthoredNotes == nil {
		m.removedauthoredNotes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.authoredNotes, ids[i])
		m.removedauthoredNotes[ids[i]] = struct{}{}
	}
}

// RemovedAuthoredNotes returns the removed IDs of the "authoredNotes" edge to the Note entity.
func (m *UserMutation) RemovedAuthoredNotesIDs() (ids []uuid.UUID) {
	for id := range m.removedauthoredNotes {
		ids = append(ids, id)
	}
	return
}

// AuthoredNotesIDs returns the "authoredNotes" edge IDs in the mutation.
func (m *UserMutation) AuthoredNotesIDs() (ids []uuid.UUID) {
	for id := range m.authoredNotes {
		ids = append(ids, id)
	}
	return
}

// ResetAuthoredNotes resets all changes to the "authoredNotes" edge.
func (m *UserMutation) ResetAuthoredNotes() {
	m.authoredNotes = nil
	m.clearedauthoredNotes = false
	m.removedauthoredNotes = nil
}

// AddMentionedNoteIDs adds the "mentionedNotes" edge to the Note entity by ids.
func (m *UserMutation) AddMentionedNoteIDs(ids ...uuid.UUID) {
	if m.mentionedNotes == nil {
		m.mentionedNotes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mentionedNotes[ids[i]] = struct{}{}
	}
}

// ClearMentionedNotes clears the "mentionedNotes" edge to the Note entity.
func (m *UserMutation) ClearMentionedNotes() {
	m.clearedmentionedNotes = true
}

// MentionedNotesCleared reports if the "mentionedNotes" edge to the Note entity was cleared.
func (m *UserMutation) MentionedNotesCleared() bool {
	return m.clearedmentionedNotes
}

// RemoveMentionedNoteIDs removes the "mentionedNotes" edge to the Note entity by IDs.
func (m *UserMutation) RemoveMentionedNoteIDs(ids ...uuid.UUID) {
	if m.removedmentionedNotes == nil {
		m.removedmentionedNotes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mentionedNotes, ids[i])
		m.removedmentionedNotes[ids[i]] = struct{}{}
	}
}

// RemovedMentionedNotes returns the removed IDs of the "mentionedNotes" edge to the Note entity.
func (m *UserMutation) RemovedMentionedNotesIDs() (ids []uuid.UUID) {
	for id := range m.removedmentionedNotes {
		ids = append(ids, id)
	}
	return
}

// MentionedNotesIDs returns the "mentionedNotes" edge IDs in the mutation.
func (m *UserMutation) MentionedNotesIDs() (ids []uuid.UUID) {
	for id := range m.mentionedNotes {
		ids = append(ids, id)
	}
	return
}

// ResetMentionedNotes resets all changes to the "mentionedNotes" edge.
func (m *UserMutation) ResetMentionedNotes() {
	m.mentionedNotes = nil
	m.clearedmentionedNotes = false
	m.removedmentionedNotes = nil
}

// AddServerIDs adds the "servers" edge to the InstanceMetadata entity by ids.
func (m *UserMutation) AddServerIDs(ids ...uuid.UUID) {
	if m.servers == nil {
		m.servers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the "servers" edge to the InstanceMetadata entity.
func (m *UserMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared reports if the "servers" edge to the InstanceMetadata entity was cleared.
func (m *UserMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the "servers" edge to the InstanceMetadata entity by IDs.
func (m *UserMutation) RemoveServerIDs(ids ...uuid.UUID) {
	if m.removedservers == nil {
		m.removedservers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.servers, ids[i])
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed IDs of the "servers" edge to the InstanceMetadata entity.
func (m *UserMutation) RemovedServersIDs() (ids []uuid.UUID) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the "servers" edge IDs in the mutation.
func (m *UserMutation) ServersIDs() (ids []uuid.UUID) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers resets all changes to the "servers" edge.
func (m *UserMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// AddModeratedServerIDs adds the "moderatedServers" edge to the InstanceMetadata entity by ids.
func (m *UserMutation) AddModeratedServerIDs(ids ...uuid.UUID) {
	if m.moderatedServers == nil {
		m.moderatedServers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.moderatedServers[ids[i]] = struct{}{}
	}
}

// ClearModeratedServers clears the "moderatedServers" edge to the InstanceMetadata entity.
func (m *UserMutation) ClearModeratedServers() {
	m.clearedmoderatedServers = true
}

// ModeratedServersCleared reports if the "moderatedServers" edge to the InstanceMetadata entity was cleared.
func (m *UserMutation) ModeratedServersCleared() bool {
	return m.clearedmoderatedServers
}

// RemoveModeratedServerIDs removes the "moderatedServers" edge to the InstanceMetadata entity by IDs.
func (m *UserMutation) RemoveModeratedServerIDs(ids ...uuid.UUID) {
	if m.removedmoderatedServers == nil {
		m.removedmoderatedServers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.moderatedServers, ids[i])
		m.removedmoderatedServers[ids[i]] = struct{}{}
	}
}

// RemovedModeratedServers returns the removed IDs of the "moderatedServers" edge to the InstanceMetadata entity.
func (m *UserMutation) RemovedModeratedServersIDs() (ids []uuid.UUID) {
	for id := range m.removedmoderatedServers {
		ids = append(ids, id)
	}
	return
}

// ModeratedServersIDs returns the "moderatedServers" edge IDs in the mutation.
func (m *UserMutation) ModeratedServersIDs() (ids []uuid.UUID) {
	for id := range m.moderatedServers {
		ids = append(ids, id)
	}
	return
}

// ResetModeratedServers resets all changes to the "moderatedServers" edge.
func (m *UserMutation) ResetModeratedServers() {
	m.moderatedServers = nil
	m.clearedmoderatedServers = false
	m.removedmoderatedServers = nil
}

// AddAdministeredServerIDs adds the "administeredServers" edge to the InstanceMetadata entity by ids.
func (m *UserMutation) AddAdministeredServerIDs(ids ...uuid.UUID) {
	if m.administeredServers == nil {
		m.administeredServers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.administeredServers[ids[i]] = struct{}{}
	}
}

// ClearAdministeredServers clears the "administeredServers" edge to the InstanceMetadata entity.
func (m *UserMutation) ClearAdministeredServers() {
	m.clearedadministeredServers = true
}

// AdministeredServersCleared reports if the "administeredServers" edge to the InstanceMetadata entity was cleared.
func (m *UserMutation) AdministeredServersCleared() bool {
	return m.clearedadministeredServers
}

// RemoveAdministeredServerIDs removes the "administeredServers" edge to the InstanceMetadata entity by IDs.
func (m *UserMutation) RemoveAdministeredServerIDs(ids ...uuid.UUID) {
	if m.removedadministeredServers == nil {
		m.removedadministeredServers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.administeredServers, ids[i])
		m.removedadministeredServers[ids[i]] = struct{}{}
	}
}

// RemovedAdministeredServers returns the removed IDs of the "administeredServers" edge to the InstanceMetadata entity.
func (m *UserMutation) RemovedAdministeredServersIDs() (ids []uuid.UUID) {
	for id := range m.removedadministeredServers {
		ids = append(ids, id)
	}
	return
}

// AdministeredServersIDs returns the "administeredServers" edge IDs in the mutation.
func (m *UserMutation) AdministeredServersIDs() (ids []uuid.UUID) {
	for id := range m.administeredServers {
		ids = append(ids, id)
	}
	return
}

// ResetAdministeredServers resets all changes to the "administeredServers" edge.
func (m *UserMutation) ResetAdministeredServers() {
	m.administeredServers = nil
	m.clearedadministeredServers = false
	m.removedadministeredServers = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.isRemote != nil {
		fields = append(fields, user.FieldIsRemote)
	}
	if m.uri != nil {
		fields = append(fields, user.FieldURI)
	}
	if m.extensions != nil {
		fields = append(fields, user.FieldExtensions)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.passwordHash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.displayName != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.biography != nil {
		fields = append(fields, user.FieldBiography)
	}
	if m.publicKey != nil {
		fields = append(fields, user.FieldPublicKey)
	}
	if m.publicKeyActor != nil {
		fields = append(fields, user.FieldPublicKeyActor)
	}
	if m.publicKeyAlgorithm != nil {
		fields = append(fields, user.FieldPublicKeyAlgorithm)
	}
	if m.privateKey != nil {
		fields = append(fields, user.FieldPrivateKey)
	}
	if m.indexable != nil {
		fields = append(fields, user.FieldIndexable)
	}
	if m.privacyLevel != nil {
		fields = append(fields, user.FieldPrivacyLevel)
	}
	if m.fields != nil {
		fields = append(fields, user.FieldFields)
	}
	if m.inbox != nil {
		fields = append(fields, user.FieldInbox)
	}
	if m.featured != nil {
		fields = append(fields, user.FieldFeatured)
	}
	if m.followers != nil {
		fields = append(fields, user.FieldFollowers)
	}
	if m.following != nil {
		fields = append(fields, user.FieldFollowing)
	}
	if m.outbox != nil {
		fields = append(fields, user.FieldOutbox)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldIsRemote:
		return m.IsRemote()
	case user.FieldURI:
		return m.URI()
	case user.FieldExtensions:
		return m.Extensions()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldBiography:
		return m.Biography()
	case user.FieldPublicKey:
		return m.PublicKey()
	case user.FieldPublicKeyActor:
		return m.PublicKeyActor()
	case user.FieldPublicKeyAlgorithm:
		return m.PublicKeyAlgorithm()
	case user.FieldPrivateKey:
		return m.PrivateKey()
	case user.FieldIndexable:
		return m.Indexable()
	case user.FieldPrivacyLevel:
		return m.PrivacyLevel()
	case user.FieldFields:
		return m.GetFields()
	case user.FieldInbox:
		return m.Inbox()
	case user.FieldFeatured:
		return m.Featured()
	case user.FieldFollowers:
		return m.Followers()
	case user.FieldFollowing:
		return m.Following()
	case user.FieldOutbox:
		return m.Outbox()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldIsRemote:
		return m.OldIsRemote(ctx)
	case user.FieldURI:
		return m.OldURI(ctx)
	case user.FieldExtensions:
		return m.OldExtensions(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldBiography:
		return m.OldBiography(ctx)
	case user.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case user.FieldPublicKeyActor:
		return m.OldPublicKeyActor(ctx)
	case user.FieldPublicKeyAlgorithm:
		return m.OldPublicKeyAlgorithm(ctx)
	case user.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case user.FieldIndexable:
		return m.OldIndexable(ctx)
	case user.FieldPrivacyLevel:
		return m.OldPrivacyLevel(ctx)
	case user.FieldFields:
		return m.OldFields(ctx)
	case user.FieldInbox:
		return m.OldInbox(ctx)
	case user.FieldFeatured:
		return m.OldFeatured(ctx)
	case user.FieldFollowers:
		return m.OldFollowers(ctx)
	case user.FieldFollowing:
		return m.OldFollowing(ctx)
	case user.FieldOutbox:
		return m.OldOutbox(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldIsRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemote(v)
		return nil
	case user.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case user.FieldExtensions:
		v, ok := value.(versia.Extensions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensions(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldBiography:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiography(v)
		return nil
	case user.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case user.FieldPublicKeyActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeyActor(v)
		return nil
	case user.FieldPublicKeyAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKeyAlgorithm(v)
		return nil
	case user.FieldPrivateKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case user.FieldIndexable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexable(v)
		return nil
	case user.FieldPrivacyLevel:
		v, ok := value.(user.PrivacyLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivacyLevel(v)
		return nil
	case user.FieldFields:
		v, ok := value.([]versia.UserField)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case user.FieldInbox:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInbox(v)
		return nil
	case user.FieldFeatured:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatured(v)
		return nil
	case user.FieldFollowers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowers(v)
		return nil
	case user.FieldFollowing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowing(v)
		return nil
	case user.FieldOutbox:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutbox(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldBiography) {
		fields = append(fields, user.FieldBiography)
	}
	if m.FieldCleared(user.FieldPrivateKey) {
		fields = append(fields, user.FieldPrivateKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldBiography:
		m.ClearBiography()
		return nil
	case user.FieldPrivateKey:
		m.ClearPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldIsRemote:
		m.ResetIsRemote()
		return nil
	case user.FieldURI:
		m.ResetURI()
		return nil
	case user.FieldExtensions:
		m.ResetExtensions()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldBiography:
		m.ResetBiography()
		return nil
	case user.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case user.FieldPublicKeyActor:
		m.ResetPublicKeyActor()
		return nil
	case user.FieldPublicKeyAlgorithm:
		m.ResetPublicKeyAlgorithm()
		return nil
	case user.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case user.FieldIndexable:
		m.ResetIndexable()
		return nil
	case user.FieldPrivacyLevel:
		m.ResetPrivacyLevel()
		return nil
	case user.FieldFields:
		m.ResetFields()
		return nil
	case user.FieldInbox:
		m.ResetInbox()
		return nil
	case user.FieldFeatured:
		m.ResetFeatured()
		return nil
	case user.FieldFollowers:
		m.ResetFollowers()
		return nil
	case user.FieldFollowing:
		m.ResetFollowing()
		return nil
	case user.FieldOutbox:
		m.ResetOutbox()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.avatarImage != nil {
		edges = append(edges, user.EdgeAvatarImage)
	}
	if m.headerImage != nil {
		edges = append(edges, user.EdgeHeaderImage)
	}
	if m.authoredNotes != nil {
		edges = append(edges, user.EdgeAuthoredNotes)
	}
	if m.mentionedNotes != nil {
		edges = append(edges, user.EdgeMentionedNotes)
	}
	if m.servers != nil {
		edges = append(edges, user.EdgeServers)
	}
	if m.moderatedServers != nil {
		edges = append(edges, user.EdgeModeratedServers)
	}
	if m.administeredServers != nil {
		edges = append(edges, user.EdgeAdministeredServers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAvatarImage:
		if id := m.avatarImage; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeHeaderImage:
		if id := m.headerImage; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAuthoredNotes:
		ids := make([]ent.Value, 0, len(m.authoredNotes))
		for id := range m.authoredNotes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMentionedNotes:
		ids := make([]ent.Value, 0, len(m.mentionedNotes))
		for id := range m.mentionedNotes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModeratedServers:
		ids := make([]ent.Value, 0, len(m.moderatedServers))
		for id := range m.moderatedServers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAdministeredServers:
		ids := make([]ent.Value, 0, len(m.administeredServers))
		for id := range m.administeredServers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedauthoredNotes != nil {
		edges = append(edges, user.EdgeAuthoredNotes)
	}
	if m.removedmentionedNotes != nil {
		edges = append(edges, user.EdgeMentionedNotes)
	}
	if m.removedservers != nil {
		edges = append(edges, user.EdgeServers)
	}
	if m.removedmoderatedServers != nil {
		edges = append(edges, user.EdgeModeratedServers)
	}
	if m.removedadministeredServers != nil {
		edges = append(edges, user.EdgeAdministeredServers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuthoredNotes:
		ids := make([]ent.Value, 0, len(m.removedauthoredNotes))
		for id := range m.removedauthoredNotes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMentionedNotes:
		ids := make([]ent.Value, 0, len(m.removedmentionedNotes))
		for id := range m.removedmentionedNotes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModeratedServers:
		ids := make([]ent.Value, 0, len(m.removedmoderatedServers))
		for id := range m.removedmoderatedServers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAdministeredServers:
		ids := make([]ent.Value, 0, len(m.removedadministeredServers))
		for id := range m.removedadministeredServers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedavatarImage {
		edges = append(edges, user.EdgeAvatarImage)
	}
	if m.clearedheaderImage {
		edges = append(edges, user.EdgeHeaderImage)
	}
	if m.clearedauthoredNotes {
		edges = append(edges, user.EdgeAuthoredNotes)
	}
	if m.clearedmentionedNotes {
		edges = append(edges, user.EdgeMentionedNotes)
	}
	if m.clearedservers {
		edges = append(edges, user.EdgeServers)
	}
	if m.clearedmoderatedServers {
		edges = append(edges, user.EdgeModeratedServers)
	}
	if m.clearedadministeredServers {
		edges = append(edges, user.EdgeAdministeredServers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAvatarImage:
		return m.clearedavatarImage
	case user.EdgeHeaderImage:
		return m.clearedheaderImage
	case user.EdgeAuthoredNotes:
		return m.clearedauthoredNotes
	case user.EdgeMentionedNotes:
		return m.clearedmentionedNotes
	case user.EdgeServers:
		return m.clearedservers
	case user.EdgeModeratedServers:
		return m.clearedmoderatedServers
	case user.EdgeAdministeredServers:
		return m.clearedadministeredServers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeAvatarImage:
		m.ClearAvatarImage()
		return nil
	case user.EdgeHeaderImage:
		m.ClearHeaderImage()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAvatarImage:
		m.ResetAvatarImage()
		return nil
	case user.EdgeHeaderImage:
		m.ResetHeaderImage()
		return nil
	case user.EdgeAuthoredNotes:
		m.ResetAuthoredNotes()
		return nil
	case user.EdgeMentionedNotes:
		m.ResetMentionedNotes()
		return nil
	case user.EdgeServers:
		m.ResetServers()
		return nil
	case user.EdgeModeratedServers:
		m.ResetModeratedServers()
		return nil
	case user.EdgeAdministeredServers:
		m.ResetAdministeredServers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
