// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/versia-pub/versia-go/ent/instancemetadata"
	"github.com/versia-pub/versia-go/ent/predicate"
	"github.com/versia-pub/versia-go/ent/user"
	"github.com/versia-pub/versia-go/pkg/versia"
)

// InstanceMetadataUpdate is the builder for updating InstanceMetadata entities.
type InstanceMetadataUpdate struct {
	config
	hooks    []Hook
	mutation *InstanceMetadataMutation
}

// Where appends a list predicates to the InstanceMetadataUpdate builder.
func (imu *InstanceMetadataUpdate) Where(ps ...predicate.InstanceMetadata) *InstanceMetadataUpdate {
	imu.mutation.Where(ps...)
	return imu
}

// SetIsRemote sets the "isRemote" field.
func (imu *InstanceMetadataUpdate) SetIsRemote(b bool) *InstanceMetadataUpdate {
	imu.mutation.SetIsRemote(b)
	return imu
}

// SetNillableIsRemote sets the "isRemote" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableIsRemote(b *bool) *InstanceMetadataUpdate {
	if b != nil {
		imu.SetIsRemote(*b)
	}
	return imu
}

// SetURI sets the "uri" field.
func (imu *InstanceMetadataUpdate) SetURI(s string) *InstanceMetadataUpdate {
	imu.mutation.SetURI(s)
	return imu
}

// SetNillableURI sets the "uri" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableURI(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetURI(*s)
	}
	return imu
}

// SetExtensions sets the "extensions" field.
func (imu *InstanceMetadataUpdate) SetExtensions(v versia.Extensions) *InstanceMetadataUpdate {
	imu.mutation.SetExtensions(v)
	return imu
}

// SetUpdatedAt sets the "updated_at" field.
func (imu *InstanceMetadataUpdate) SetUpdatedAt(t time.Time) *InstanceMetadataUpdate {
	imu.mutation.SetUpdatedAt(t)
	return imu
}

// SetName sets the "name" field.
func (imu *InstanceMetadataUpdate) SetName(s string) *InstanceMetadataUpdate {
	imu.mutation.SetName(s)
	return imu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableName(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetName(*s)
	}
	return imu
}

// SetDescription sets the "description" field.
func (imu *InstanceMetadataUpdate) SetDescription(s string) *InstanceMetadataUpdate {
	imu.mutation.SetDescription(s)
	return imu
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableDescription(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetDescription(*s)
	}
	return imu
}

// ClearDescription clears the value of the "description" field.
func (imu *InstanceMetadataUpdate) ClearDescription() *InstanceMetadataUpdate {
	imu.mutation.ClearDescription()
	return imu
}

// SetHost sets the "host" field.
func (imu *InstanceMetadataUpdate) SetHost(s string) *InstanceMetadataUpdate {
	imu.mutation.SetHost(s)
	return imu
}

// SetNillableHost sets the "host" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableHost(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetHost(*s)
	}
	return imu
}

// SetPublicKey sets the "publicKey" field.
func (imu *InstanceMetadataUpdate) SetPublicKey(b []byte) *InstanceMetadataUpdate {
	imu.mutation.SetPublicKey(b)
	return imu
}

// SetPublicKeyAlgorithm sets the "publicKeyAlgorithm" field.
func (imu *InstanceMetadataUpdate) SetPublicKeyAlgorithm(s string) *InstanceMetadataUpdate {
	imu.mutation.SetPublicKeyAlgorithm(s)
	return imu
}

// SetNillablePublicKeyAlgorithm sets the "publicKeyAlgorithm" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillablePublicKeyAlgorithm(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetPublicKeyAlgorithm(*s)
	}
	return imu
}

// SetPrivateKey sets the "privateKey" field.
func (imu *InstanceMetadataUpdate) SetPrivateKey(b []byte) *InstanceMetadataUpdate {
	imu.mutation.SetPrivateKey(b)
	return imu
}

// ClearPrivateKey clears the value of the "privateKey" field.
func (imu *InstanceMetadataUpdate) ClearPrivateKey() *InstanceMetadataUpdate {
	imu.mutation.ClearPrivateKey()
	return imu
}

// SetSoftwareName sets the "softwareName" field.
func (imu *InstanceMetadataUpdate) SetSoftwareName(s string) *InstanceMetadataUpdate {
	imu.mutation.SetSoftwareName(s)
	return imu
}

// SetNillableSoftwareName sets the "softwareName" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableSoftwareName(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetSoftwareName(*s)
	}
	return imu
}

// SetSoftwareVersion sets the "softwareVersion" field.
func (imu *InstanceMetadataUpdate) SetSoftwareVersion(s string) *InstanceMetadataUpdate {
	imu.mutation.SetSoftwareVersion(s)
	return imu
}

// SetNillableSoftwareVersion sets the "softwareVersion" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableSoftwareVersion(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetSoftwareVersion(*s)
	}
	return imu
}

// SetSharedInboxURI sets the "sharedInboxURI" field.
func (imu *InstanceMetadataUpdate) SetSharedInboxURI(s string) *InstanceMetadataUpdate {
	imu.mutation.SetSharedInboxURI(s)
	return imu
}

// SetNillableSharedInboxURI sets the "sharedInboxURI" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableSharedInboxURI(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetSharedInboxURI(*s)
	}
	return imu
}

// SetModeratorsURI sets the "moderatorsURI" field.
func (imu *InstanceMetadataUpdate) SetModeratorsURI(s string) *InstanceMetadataUpdate {
	imu.mutation.SetModeratorsURI(s)
	return imu
}

// SetNillableModeratorsURI sets the "moderatorsURI" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableModeratorsURI(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetModeratorsURI(*s)
	}
	return imu
}

// ClearModeratorsURI clears the value of the "moderatorsURI" field.
func (imu *InstanceMetadataUpdate) ClearModeratorsURI() *InstanceMetadataUpdate {
	imu.mutation.ClearModeratorsURI()
	return imu
}

// SetAdminsURI sets the "adminsURI" field.
func (imu *InstanceMetadataUpdate) SetAdminsURI(s string) *InstanceMetadataUpdate {
	imu.mutation.SetAdminsURI(s)
	return imu
}

// SetNillableAdminsURI sets the "adminsURI" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableAdminsURI(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetAdminsURI(*s)
	}
	return imu
}

// ClearAdminsURI clears the value of the "adminsURI" field.
func (imu *InstanceMetadataUpdate) ClearAdminsURI() *InstanceMetadataUpdate {
	imu.mutation.ClearAdminsURI()
	return imu
}

// SetLogoEndpoint sets the "logoEndpoint" field.
func (imu *InstanceMetadataUpdate) SetLogoEndpoint(s string) *InstanceMetadataUpdate {
	imu.mutation.SetLogoEndpoint(s)
	return imu
}

// SetNillableLogoEndpoint sets the "logoEndpoint" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableLogoEndpoint(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetLogoEndpoint(*s)
	}
	return imu
}

// ClearLogoEndpoint clears the value of the "logoEndpoint" field.
func (imu *InstanceMetadataUpdate) ClearLogoEndpoint() *InstanceMetadataUpdate {
	imu.mutation.ClearLogoEndpoint()
	return imu
}

// SetLogoMimeType sets the "logoMimeType" field.
func (imu *InstanceMetadataUpdate) SetLogoMimeType(s string) *InstanceMetadataUpdate {
	imu.mutation.SetLogoMimeType(s)
	return imu
}

// SetNillableLogoMimeType sets the "logoMimeType" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableLogoMimeType(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetLogoMimeType(*s)
	}
	return imu
}

// ClearLogoMimeType clears the value of the "logoMimeType" field.
func (imu *InstanceMetadataUpdate) ClearLogoMimeType() *InstanceMetadataUpdate {
	imu.mutation.ClearLogoMimeType()
	return imu
}

// SetBannerEndpoint sets the "bannerEndpoint" field.
func (imu *InstanceMetadataUpdate) SetBannerEndpoint(s string) *InstanceMetadataUpdate {
	imu.mutation.SetBannerEndpoint(s)
	return imu
}

// SetNillableBannerEndpoint sets the "bannerEndpoint" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableBannerEndpoint(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetBannerEndpoint(*s)
	}
	return imu
}

// ClearBannerEndpoint clears the value of the "bannerEndpoint" field.
func (imu *InstanceMetadataUpdate) ClearBannerEndpoint() *InstanceMetadataUpdate {
	imu.mutation.ClearBannerEndpoint()
	return imu
}

// SetBannerMimeType sets the "bannerMimeType" field.
func (imu *InstanceMetadataUpdate) SetBannerMimeType(s string) *InstanceMetadataUpdate {
	imu.mutation.SetBannerMimeType(s)
	return imu
}

// SetNillableBannerMimeType sets the "bannerMimeType" field if the given value is not nil.
func (imu *InstanceMetadataUpdate) SetNillableBannerMimeType(s *string) *InstanceMetadataUpdate {
	if s != nil {
		imu.SetBannerMimeType(*s)
	}
	return imu
}

// ClearBannerMimeType clears the value of the "bannerMimeType" field.
func (imu *InstanceMetadataUpdate) ClearBannerMimeType() *InstanceMetadataUpdate {
	imu.mutation.ClearBannerMimeType()
	return imu
}

// SetSupportedVersions sets the "supportedVersions" field.
func (imu *InstanceMetadataUpdate) SetSupportedVersions(s []string) *InstanceMetadataUpdate {
	imu.mutation.SetSupportedVersions(s)
	return imu
}

// AppendSupportedVersions appends s to the "supportedVersions" field.
func (imu *InstanceMetadataUpdate) AppendSupportedVersions(s []string) *InstanceMetadataUpdate {
	imu.mutation.AppendSupportedVersions(s)
	return imu
}

// SetSupportedExtensions sets the "supportedExtensions" field.
func (imu *InstanceMetadataUpdate) SetSupportedExtensions(s []string) *InstanceMetadataUpdate {
	imu.mutation.SetSupportedExtensions(s)
	return imu
}

// AppendSupportedExtensions appends s to the "supportedExtensions" field.
func (imu *InstanceMetadataUpdate) AppendSupportedExtensions(s []string) *InstanceMetadataUpdate {
	imu.mutation.AppendSupportedExtensions(s)
	return imu
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (imu *InstanceMetadataUpdate) AddUserIDs(ids ...uuid.UUID) *InstanceMetadataUpdate {
	imu.mutation.AddUserIDs(ids...)
	return imu
}

// AddUsers adds the "users" edges to the User entity.
func (imu *InstanceMetadataUpdate) AddUsers(u ...*User) *InstanceMetadataUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imu.AddUserIDs(ids...)
}

// AddModeratorIDs adds the "moderators" edge to the User entity by IDs.
func (imu *InstanceMetadataUpdate) AddModeratorIDs(ids ...uuid.UUID) *InstanceMetadataUpdate {
	imu.mutation.AddModeratorIDs(ids...)
	return imu
}

// AddModerators adds the "moderators" edges to the User entity.
func (imu *InstanceMetadataUpdate) AddModerators(u ...*User) *InstanceMetadataUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imu.AddModeratorIDs(ids...)
}

// AddAdminIDs adds the "admins" edge to the User entity by IDs.
func (imu *InstanceMetadataUpdate) AddAdminIDs(ids ...uuid.UUID) *InstanceMetadataUpdate {
	imu.mutation.AddAdminIDs(ids...)
	return imu
}

// AddAdmins adds the "admins" edges to the User entity.
func (imu *InstanceMetadataUpdate) AddAdmins(u ...*User) *InstanceMetadataUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imu.AddAdminIDs(ids...)
}

// Mutation returns the InstanceMetadataMutation object of the builder.
func (imu *InstanceMetadataUpdate) Mutation() *InstanceMetadataMutation {
	return imu.mutation
}

// ClearUsers clears all "users" edges to the User entity.
func (imu *InstanceMetadataUpdate) ClearUsers() *InstanceMetadataUpdate {
	imu.mutation.ClearUsers()
	return imu
}

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (imu *InstanceMetadataUpdate) RemoveUserIDs(ids ...uuid.UUID) *InstanceMetadataUpdate {
	imu.mutation.RemoveUserIDs(ids...)
	return imu
}

// RemoveUsers removes "users" edges to User entities.
func (imu *InstanceMetadataUpdate) RemoveUsers(u ...*User) *InstanceMetadataUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imu.RemoveUserIDs(ids...)
}

// ClearModerators clears all "moderators" edges to the User entity.
func (imu *InstanceMetadataUpdate) ClearModerators() *InstanceMetadataUpdate {
	imu.mutation.ClearModerators()
	return imu
}

// RemoveModeratorIDs removes the "moderators" edge to User entities by IDs.
func (imu *InstanceMetadataUpdate) RemoveModeratorIDs(ids ...uuid.UUID) *InstanceMetadataUpdate {
	imu.mutation.RemoveModeratorIDs(ids...)
	return imu
}

// RemoveModerators removes "moderators" edges to User entities.
func (imu *InstanceMetadataUpdate) RemoveModerators(u ...*User) *InstanceMetadataUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imu.RemoveModeratorIDs(ids...)
}

// ClearAdmins clears all "admins" edges to the User entity.
func (imu *InstanceMetadataUpdate) ClearAdmins() *InstanceMetadataUpdate {
	imu.mutation.ClearAdmins()
	return imu
}

// RemoveAdminIDs removes the "admins" edge to User entities by IDs.
func (imu *InstanceMetadataUpdate) RemoveAdminIDs(ids ...uuid.UUID) *InstanceMetadataUpdate {
	imu.mutation.RemoveAdminIDs(ids...)
	return imu
}

// RemoveAdmins removes "admins" edges to User entities.
func (imu *InstanceMetadataUpdate) RemoveAdmins(u ...*User) *InstanceMetadataUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imu.RemoveAdminIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (imu *InstanceMetadataUpdate) Save(ctx context.Context) (int, error) {
	imu.defaults()
	return withHooks(ctx, imu.sqlSave, imu.mutation, imu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (imu *InstanceMetadataUpdate) SaveX(ctx context.Context) int {
	affected, err := imu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (imu *InstanceMetadataUpdate) Exec(ctx context.Context) error {
	_, err := imu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (imu *InstanceMetadataUpdate) ExecX(ctx context.Context) {
	if err := imu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (imu *InstanceMetadataUpdate) defaults() {
	if _, ok := imu.mutation.UpdatedAt(); !ok {
		v := instancemetadata.UpdateDefaultUpdatedAt()
		imu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (imu *InstanceMetadataUpdate) check() error {
	if v, ok := imu.mutation.URI(); ok {
		if err := instancemetadata.URIValidator(v); err != nil {
			return &ValidationError{Name: "uri", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.uri": %w`, err)}
		}
	}
	if v, ok := imu.mutation.Name(); ok {
		if err := instancemetadata.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.name": %w`, err)}
		}
	}
	if v, ok := imu.mutation.Host(); ok {
		if err := instancemetadata.HostValidator(v); err != nil {
			return &ValidationError{Name: "host", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.host": %w`, err)}
		}
	}
	if v, ok := imu.mutation.SoftwareName(); ok {
		if err := instancemetadata.SoftwareNameValidator(v); err != nil {
			return &ValidationError{Name: "softwareName", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.softwareName": %w`, err)}
		}
	}
	if v, ok := imu.mutation.SoftwareVersion(); ok {
		if err := instancemetadata.SoftwareVersionValidator(v); err != nil {
			return &ValidationError{Name: "softwareVersion", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.softwareVersion": %w`, err)}
		}
	}
	if v, ok := imu.mutation.SharedInboxURI(); ok {
		if err := instancemetadata.SharedInboxURIValidator(v); err != nil {
			return &ValidationError{Name: "sharedInboxURI", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.sharedInboxURI": %w`, err)}
		}
	}
	if v, ok := imu.mutation.ModeratorsURI(); ok {
		if err := instancemetadata.ModeratorsURIValidator(v); err != nil {
			return &ValidationError{Name: "moderatorsURI", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.moderatorsURI": %w`, err)}
		}
	}
	if v, ok := imu.mutation.AdminsURI(); ok {
		if err := instancemetadata.AdminsURIValidator(v); err != nil {
			return &ValidationError{Name: "adminsURI", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.adminsURI": %w`, err)}
		}
	}
	if v, ok := imu.mutation.LogoEndpoint(); ok {
		if err := instancemetadata.LogoEndpointValidator(v); err != nil {
			return &ValidationError{Name: "logoEndpoint", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.logoEndpoint": %w`, err)}
		}
	}
	if v, ok := imu.mutation.LogoMimeType(); ok {
		if err := instancemetadata.LogoMimeTypeValidator(v); err != nil {
			return &ValidationError{Name: "logoMimeType", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.logoMimeType": %w`, err)}
		}
	}
	if v, ok := imu.mutation.BannerEndpoint(); ok {
		if err := instancemetadata.BannerEndpointValidator(v); err != nil {
			return &ValidationError{Name: "bannerEndpoint", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.bannerEndpoint": %w`, err)}
		}
	}
	if v, ok := imu.mutation.BannerMimeType(); ok {
		if err := instancemetadata.BannerMimeTypeValidator(v); err != nil {
			return &ValidationError{Name: "bannerMimeType", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.bannerMimeType": %w`, err)}
		}
	}
	return nil
}

func (imu *InstanceMetadataUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := imu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(instancemetadata.Table, instancemetadata.Columns, sqlgraph.NewFieldSpec(instancemetadata.FieldID, field.TypeUUID))
	if ps := imu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := imu.mutation.IsRemote(); ok {
		_spec.SetField(instancemetadata.FieldIsRemote, field.TypeBool, value)
	}
	if value, ok := imu.mutation.URI(); ok {
		_spec.SetField(instancemetadata.FieldURI, field.TypeString, value)
	}
	if value, ok := imu.mutation.Extensions(); ok {
		_spec.SetField(instancemetadata.FieldExtensions, field.TypeJSON, value)
	}
	if value, ok := imu.mutation.UpdatedAt(); ok {
		_spec.SetField(instancemetadata.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := imu.mutation.Name(); ok {
		_spec.SetField(instancemetadata.FieldName, field.TypeString, value)
	}
	if value, ok := imu.mutation.Description(); ok {
		_spec.SetField(instancemetadata.FieldDescription, field.TypeString, value)
	}
	if imu.mutation.DescriptionCleared() {
		_spec.ClearField(instancemetadata.FieldDescription, field.TypeString)
	}
	if value, ok := imu.mutation.Host(); ok {
		_spec.SetField(instancemetadata.FieldHost, field.TypeString, value)
	}
	if value, ok := imu.mutation.PublicKey(); ok {
		_spec.SetField(instancemetadata.FieldPublicKey, field.TypeBytes, value)
	}
	if value, ok := imu.mutation.PublicKeyAlgorithm(); ok {
		_spec.SetField(instancemetadata.FieldPublicKeyAlgorithm, field.TypeString, value)
	}
	if value, ok := imu.mutation.PrivateKey(); ok {
		_spec.SetField(instancemetadata.FieldPrivateKey, field.TypeBytes, value)
	}
	if imu.mutation.PrivateKeyCleared() {
		_spec.ClearField(instancemetadata.FieldPrivateKey, field.TypeBytes)
	}
	if value, ok := imu.mutation.SoftwareName(); ok {
		_spec.SetField(instancemetadata.FieldSoftwareName, field.TypeString, value)
	}
	if value, ok := imu.mutation.SoftwareVersion(); ok {
		_spec.SetField(instancemetadata.FieldSoftwareVersion, field.TypeString, value)
	}
	if value, ok := imu.mutation.SharedInboxURI(); ok {
		_spec.SetField(instancemetadata.FieldSharedInboxURI, field.TypeString, value)
	}
	if value, ok := imu.mutation.ModeratorsURI(); ok {
		_spec.SetField(instancemetadata.FieldModeratorsURI, field.TypeString, value)
	}
	if imu.mutation.ModeratorsURICleared() {
		_spec.ClearField(instancemetadata.FieldModeratorsURI, field.TypeString)
	}
	if value, ok := imu.mutation.AdminsURI(); ok {
		_spec.SetField(instancemetadata.FieldAdminsURI, field.TypeString, value)
	}
	if imu.mutation.AdminsURICleared() {
		_spec.ClearField(instancemetadata.FieldAdminsURI, field.TypeString)
	}
	if value, ok := imu.mutation.LogoEndpoint(); ok {
		_spec.SetField(instancemetadata.FieldLogoEndpoint, field.TypeString, value)
	}
	if imu.mutation.LogoEndpointCleared() {
		_spec.ClearField(instancemetadata.FieldLogoEndpoint, field.TypeString)
	}
	if value, ok := imu.mutation.LogoMimeType(); ok {
		_spec.SetField(instancemetadata.FieldLogoMimeType, field.TypeString, value)
	}
	if imu.mutation.LogoMimeTypeCleared() {
		_spec.ClearField(instancemetadata.FieldLogoMimeType, field.TypeString)
	}
	if value, ok := imu.mutation.BannerEndpoint(); ok {
		_spec.SetField(instancemetadata.FieldBannerEndpoint, field.TypeString, value)
	}
	if imu.mutation.BannerEndpointCleared() {
		_spec.ClearField(instancemetadata.FieldBannerEndpoint, field.TypeString)
	}
	if value, ok := imu.mutation.BannerMimeType(); ok {
		_spec.SetField(instancemetadata.FieldBannerMimeType, field.TypeString, value)
	}
	if imu.mutation.BannerMimeTypeCleared() {
		_spec.ClearField(instancemetadata.FieldBannerMimeType, field.TypeString)
	}
	if value, ok := imu.mutation.SupportedVersions(); ok {
		_spec.SetField(instancemetadata.FieldSupportedVersions, field.TypeJSON, value)
	}
	if value, ok := imu.mutation.AppendedSupportedVersions(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, instancemetadata.FieldSupportedVersions, value)
		})
	}
	if value, ok := imu.mutation.SupportedExtensions(); ok {
		_spec.SetField(instancemetadata.FieldSupportedExtensions, field.TypeJSON, value)
	}
	if value, ok := imu.mutation.AppendedSupportedExtensions(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, instancemetadata.FieldSupportedExtensions, value)
		})
	}
	if imu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.UsersTable,
			Columns: instancemetadata.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imu.mutation.RemovedUsersIDs(); len(nodes) > 0 && !imu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.UsersTable,
			Columns: instancemetadata.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imu.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.UsersTable,
			Columns: instancemetadata.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if imu.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.ModeratorsTable,
			Columns: instancemetadata.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imu.mutation.RemovedModeratorsIDs(); len(nodes) > 0 && !imu.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.ModeratorsTable,
			Columns: instancemetadata.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imu.mutation.ModeratorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.ModeratorsTable,
			Columns: instancemetadata.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if imu.mutation.AdminsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.AdminsTable,
			Columns: instancemetadata.AdminsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imu.mutation.RemovedAdminsIDs(); len(nodes) > 0 && !imu.mutation.AdminsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.AdminsTable,
			Columns: instancemetadata.AdminsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imu.mutation.AdminsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.AdminsTable,
			Columns: instancemetadata.AdminsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, imu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{instancemetadata.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	imu.mutation.done = true
	return n, nil
}

// InstanceMetadataUpdateOne is the builder for updating a single InstanceMetadata entity.
type InstanceMetadataUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *InstanceMetadataMutation
}

// SetIsRemote sets the "isRemote" field.
func (imuo *InstanceMetadataUpdateOne) SetIsRemote(b bool) *InstanceMetadataUpdateOne {
	imuo.mutation.SetIsRemote(b)
	return imuo
}

// SetNillableIsRemote sets the "isRemote" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableIsRemote(b *bool) *InstanceMetadataUpdateOne {
	if b != nil {
		imuo.SetIsRemote(*b)
	}
	return imuo
}

// SetURI sets the "uri" field.
func (imuo *InstanceMetadataUpdateOne) SetURI(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetURI(s)
	return imuo
}

// SetNillableURI sets the "uri" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableURI(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetURI(*s)
	}
	return imuo
}

// SetExtensions sets the "extensions" field.
func (imuo *InstanceMetadataUpdateOne) SetExtensions(v versia.Extensions) *InstanceMetadataUpdateOne {
	imuo.mutation.SetExtensions(v)
	return imuo
}

// SetUpdatedAt sets the "updated_at" field.
func (imuo *InstanceMetadataUpdateOne) SetUpdatedAt(t time.Time) *InstanceMetadataUpdateOne {
	imuo.mutation.SetUpdatedAt(t)
	return imuo
}

// SetName sets the "name" field.
func (imuo *InstanceMetadataUpdateOne) SetName(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetName(s)
	return imuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableName(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetName(*s)
	}
	return imuo
}

// SetDescription sets the "description" field.
func (imuo *InstanceMetadataUpdateOne) SetDescription(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetDescription(s)
	return imuo
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableDescription(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetDescription(*s)
	}
	return imuo
}

// ClearDescription clears the value of the "description" field.
func (imuo *InstanceMetadataUpdateOne) ClearDescription() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearDescription()
	return imuo
}

// SetHost sets the "host" field.
func (imuo *InstanceMetadataUpdateOne) SetHost(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetHost(s)
	return imuo
}

// SetNillableHost sets the "host" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableHost(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetHost(*s)
	}
	return imuo
}

// SetPublicKey sets the "publicKey" field.
func (imuo *InstanceMetadataUpdateOne) SetPublicKey(b []byte) *InstanceMetadataUpdateOne {
	imuo.mutation.SetPublicKey(b)
	return imuo
}

// SetPublicKeyAlgorithm sets the "publicKeyAlgorithm" field.
func (imuo *InstanceMetadataUpdateOne) SetPublicKeyAlgorithm(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetPublicKeyAlgorithm(s)
	return imuo
}

// SetNillablePublicKeyAlgorithm sets the "publicKeyAlgorithm" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillablePublicKeyAlgorithm(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetPublicKeyAlgorithm(*s)
	}
	return imuo
}

// SetPrivateKey sets the "privateKey" field.
func (imuo *InstanceMetadataUpdateOne) SetPrivateKey(b []byte) *InstanceMetadataUpdateOne {
	imuo.mutation.SetPrivateKey(b)
	return imuo
}

// ClearPrivateKey clears the value of the "privateKey" field.
func (imuo *InstanceMetadataUpdateOne) ClearPrivateKey() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearPrivateKey()
	return imuo
}

// SetSoftwareName sets the "softwareName" field.
func (imuo *InstanceMetadataUpdateOne) SetSoftwareName(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetSoftwareName(s)
	return imuo
}

// SetNillableSoftwareName sets the "softwareName" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableSoftwareName(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetSoftwareName(*s)
	}
	return imuo
}

// SetSoftwareVersion sets the "softwareVersion" field.
func (imuo *InstanceMetadataUpdateOne) SetSoftwareVersion(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetSoftwareVersion(s)
	return imuo
}

// SetNillableSoftwareVersion sets the "softwareVersion" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableSoftwareVersion(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetSoftwareVersion(*s)
	}
	return imuo
}

// SetSharedInboxURI sets the "sharedInboxURI" field.
func (imuo *InstanceMetadataUpdateOne) SetSharedInboxURI(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetSharedInboxURI(s)
	return imuo
}

// SetNillableSharedInboxURI sets the "sharedInboxURI" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableSharedInboxURI(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetSharedInboxURI(*s)
	}
	return imuo
}

// SetModeratorsURI sets the "moderatorsURI" field.
func (imuo *InstanceMetadataUpdateOne) SetModeratorsURI(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetModeratorsURI(s)
	return imuo
}

// SetNillableModeratorsURI sets the "moderatorsURI" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableModeratorsURI(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetModeratorsURI(*s)
	}
	return imuo
}

// ClearModeratorsURI clears the value of the "moderatorsURI" field.
func (imuo *InstanceMetadataUpdateOne) ClearModeratorsURI() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearModeratorsURI()
	return imuo
}

// SetAdminsURI sets the "adminsURI" field.
func (imuo *InstanceMetadataUpdateOne) SetAdminsURI(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetAdminsURI(s)
	return imuo
}

// SetNillableAdminsURI sets the "adminsURI" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableAdminsURI(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetAdminsURI(*s)
	}
	return imuo
}

// ClearAdminsURI clears the value of the "adminsURI" field.
func (imuo *InstanceMetadataUpdateOne) ClearAdminsURI() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearAdminsURI()
	return imuo
}

// SetLogoEndpoint sets the "logoEndpoint" field.
func (imuo *InstanceMetadataUpdateOne) SetLogoEndpoint(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetLogoEndpoint(s)
	return imuo
}

// SetNillableLogoEndpoint sets the "logoEndpoint" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableLogoEndpoint(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetLogoEndpoint(*s)
	}
	return imuo
}

// ClearLogoEndpoint clears the value of the "logoEndpoint" field.
func (imuo *InstanceMetadataUpdateOne) ClearLogoEndpoint() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearLogoEndpoint()
	return imuo
}

// SetLogoMimeType sets the "logoMimeType" field.
func (imuo *InstanceMetadataUpdateOne) SetLogoMimeType(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetLogoMimeType(s)
	return imuo
}

// SetNillableLogoMimeType sets the "logoMimeType" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableLogoMimeType(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetLogoMimeType(*s)
	}
	return imuo
}

// ClearLogoMimeType clears the value of the "logoMimeType" field.
func (imuo *InstanceMetadataUpdateOne) ClearLogoMimeType() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearLogoMimeType()
	return imuo
}

// SetBannerEndpoint sets the "bannerEndpoint" field.
func (imuo *InstanceMetadataUpdateOne) SetBannerEndpoint(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetBannerEndpoint(s)
	return imuo
}

// SetNillableBannerEndpoint sets the "bannerEndpoint" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableBannerEndpoint(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetBannerEndpoint(*s)
	}
	return imuo
}

// ClearBannerEndpoint clears the value of the "bannerEndpoint" field.
func (imuo *InstanceMetadataUpdateOne) ClearBannerEndpoint() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearBannerEndpoint()
	return imuo
}

// SetBannerMimeType sets the "bannerMimeType" field.
func (imuo *InstanceMetadataUpdateOne) SetBannerMimeType(s string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetBannerMimeType(s)
	return imuo
}

// SetNillableBannerMimeType sets the "bannerMimeType" field if the given value is not nil.
func (imuo *InstanceMetadataUpdateOne) SetNillableBannerMimeType(s *string) *InstanceMetadataUpdateOne {
	if s != nil {
		imuo.SetBannerMimeType(*s)
	}
	return imuo
}

// ClearBannerMimeType clears the value of the "bannerMimeType" field.
func (imuo *InstanceMetadataUpdateOne) ClearBannerMimeType() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearBannerMimeType()
	return imuo
}

// SetSupportedVersions sets the "supportedVersions" field.
func (imuo *InstanceMetadataUpdateOne) SetSupportedVersions(s []string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetSupportedVersions(s)
	return imuo
}

// AppendSupportedVersions appends s to the "supportedVersions" field.
func (imuo *InstanceMetadataUpdateOne) AppendSupportedVersions(s []string) *InstanceMetadataUpdateOne {
	imuo.mutation.AppendSupportedVersions(s)
	return imuo
}

// SetSupportedExtensions sets the "supportedExtensions" field.
func (imuo *InstanceMetadataUpdateOne) SetSupportedExtensions(s []string) *InstanceMetadataUpdateOne {
	imuo.mutation.SetSupportedExtensions(s)
	return imuo
}

// AppendSupportedExtensions appends s to the "supportedExtensions" field.
func (imuo *InstanceMetadataUpdateOne) AppendSupportedExtensions(s []string) *InstanceMetadataUpdateOne {
	imuo.mutation.AppendSupportedExtensions(s)
	return imuo
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (imuo *InstanceMetadataUpdateOne) AddUserIDs(ids ...uuid.UUID) *InstanceMetadataUpdateOne {
	imuo.mutation.AddUserIDs(ids...)
	return imuo
}

// AddUsers adds the "users" edges to the User entity.
func (imuo *InstanceMetadataUpdateOne) AddUsers(u ...*User) *InstanceMetadataUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imuo.AddUserIDs(ids...)
}

// AddModeratorIDs adds the "moderators" edge to the User entity by IDs.
func (imuo *InstanceMetadataUpdateOne) AddModeratorIDs(ids ...uuid.UUID) *InstanceMetadataUpdateOne {
	imuo.mutation.AddModeratorIDs(ids...)
	return imuo
}

// AddModerators adds the "moderators" edges to the User entity.
func (imuo *InstanceMetadataUpdateOne) AddModerators(u ...*User) *InstanceMetadataUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imuo.AddModeratorIDs(ids...)
}

// AddAdminIDs adds the "admins" edge to the User entity by IDs.
func (imuo *InstanceMetadataUpdateOne) AddAdminIDs(ids ...uuid.UUID) *InstanceMetadataUpdateOne {
	imuo.mutation.AddAdminIDs(ids...)
	return imuo
}

// AddAdmins adds the "admins" edges to the User entity.
func (imuo *InstanceMetadataUpdateOne) AddAdmins(u ...*User) *InstanceMetadataUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imuo.AddAdminIDs(ids...)
}

// Mutation returns the InstanceMetadataMutation object of the builder.
func (imuo *InstanceMetadataUpdateOne) Mutation() *InstanceMetadataMutation {
	return imuo.mutation
}

// ClearUsers clears all "users" edges to the User entity.
func (imuo *InstanceMetadataUpdateOne) ClearUsers() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearUsers()
	return imuo
}

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (imuo *InstanceMetadataUpdateOne) RemoveUserIDs(ids ...uuid.UUID) *InstanceMetadataUpdateOne {
	imuo.mutation.RemoveUserIDs(ids...)
	return imuo
}

// RemoveUsers removes "users" edges to User entities.
func (imuo *InstanceMetadataUpdateOne) RemoveUsers(u ...*User) *InstanceMetadataUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imuo.RemoveUserIDs(ids...)
}

// ClearModerators clears all "moderators" edges to the User entity.
func (imuo *InstanceMetadataUpdateOne) ClearModerators() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearModerators()
	return imuo
}

// RemoveModeratorIDs removes the "moderators" edge to User entities by IDs.
func (imuo *InstanceMetadataUpdateOne) RemoveModeratorIDs(ids ...uuid.UUID) *InstanceMetadataUpdateOne {
	imuo.mutation.RemoveModeratorIDs(ids...)
	return imuo
}

// RemoveModerators removes "moderators" edges to User entities.
func (imuo *InstanceMetadataUpdateOne) RemoveModerators(u ...*User) *InstanceMetadataUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imuo.RemoveModeratorIDs(ids...)
}

// ClearAdmins clears all "admins" edges to the User entity.
func (imuo *InstanceMetadataUpdateOne) ClearAdmins() *InstanceMetadataUpdateOne {
	imuo.mutation.ClearAdmins()
	return imuo
}

// RemoveAdminIDs removes the "admins" edge to User entities by IDs.
func (imuo *InstanceMetadataUpdateOne) RemoveAdminIDs(ids ...uuid.UUID) *InstanceMetadataUpdateOne {
	imuo.mutation.RemoveAdminIDs(ids...)
	return imuo
}

// RemoveAdmins removes "admins" edges to User entities.
func (imuo *InstanceMetadataUpdateOne) RemoveAdmins(u ...*User) *InstanceMetadataUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return imuo.RemoveAdminIDs(ids...)
}

// Where appends a list predicates to the InstanceMetadataUpdate builder.
func (imuo *InstanceMetadataUpdateOne) Where(ps ...predicate.InstanceMetadata) *InstanceMetadataUpdateOne {
	imuo.mutation.Where(ps...)
	return imuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (imuo *InstanceMetadataUpdateOne) Select(field string, fields ...string) *InstanceMetadataUpdateOne {
	imuo.fields = append([]string{field}, fields...)
	return imuo
}

// Save executes the query and returns the updated InstanceMetadata entity.
func (imuo *InstanceMetadataUpdateOne) Save(ctx context.Context) (*InstanceMetadata, error) {
	imuo.defaults()
	return withHooks(ctx, imuo.sqlSave, imuo.mutation, imuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (imuo *InstanceMetadataUpdateOne) SaveX(ctx context.Context) *InstanceMetadata {
	node, err := imuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (imuo *InstanceMetadataUpdateOne) Exec(ctx context.Context) error {
	_, err := imuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (imuo *InstanceMetadataUpdateOne) ExecX(ctx context.Context) {
	if err := imuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (imuo *InstanceMetadataUpdateOne) defaults() {
	if _, ok := imuo.mutation.UpdatedAt(); !ok {
		v := instancemetadata.UpdateDefaultUpdatedAt()
		imuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (imuo *InstanceMetadataUpdateOne) check() error {
	if v, ok := imuo.mutation.URI(); ok {
		if err := instancemetadata.URIValidator(v); err != nil {
			return &ValidationError{Name: "uri", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.uri": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.Name(); ok {
		if err := instancemetadata.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.name": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.Host(); ok {
		if err := instancemetadata.HostValidator(v); err != nil {
			return &ValidationError{Name: "host", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.host": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.SoftwareName(); ok {
		if err := instancemetadata.SoftwareNameValidator(v); err != nil {
			return &ValidationError{Name: "softwareName", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.softwareName": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.SoftwareVersion(); ok {
		if err := instancemetadata.SoftwareVersionValidator(v); err != nil {
			return &ValidationError{Name: "softwareVersion", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.softwareVersion": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.SharedInboxURI(); ok {
		if err := instancemetadata.SharedInboxURIValidator(v); err != nil {
			return &ValidationError{Name: "sharedInboxURI", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.sharedInboxURI": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.ModeratorsURI(); ok {
		if err := instancemetadata.ModeratorsURIValidator(v); err != nil {
			return &ValidationError{Name: "moderatorsURI", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.moderatorsURI": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.AdminsURI(); ok {
		if err := instancemetadata.AdminsURIValidator(v); err != nil {
			return &ValidationError{Name: "adminsURI", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.adminsURI": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.LogoEndpoint(); ok {
		if err := instancemetadata.LogoEndpointValidator(v); err != nil {
			return &ValidationError{Name: "logoEndpoint", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.logoEndpoint": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.LogoMimeType(); ok {
		if err := instancemetadata.LogoMimeTypeValidator(v); err != nil {
			return &ValidationError{Name: "logoMimeType", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.logoMimeType": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.BannerEndpoint(); ok {
		if err := instancemetadata.BannerEndpointValidator(v); err != nil {
			return &ValidationError{Name: "bannerEndpoint", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.bannerEndpoint": %w`, err)}
		}
	}
	if v, ok := imuo.mutation.BannerMimeType(); ok {
		if err := instancemetadata.BannerMimeTypeValidator(v); err != nil {
			return &ValidationError{Name: "bannerMimeType", err: fmt.Errorf(`ent: validator failed for field "InstanceMetadata.bannerMimeType": %w`, err)}
		}
	}
	return nil
}

func (imuo *InstanceMetadataUpdateOne) sqlSave(ctx context.Context) (_node *InstanceMetadata, err error) {
	if err := imuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(instancemetadata.Table, instancemetadata.Columns, sqlgraph.NewFieldSpec(instancemetadata.FieldID, field.TypeUUID))
	id, ok := imuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "InstanceMetadata.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := imuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, instancemetadata.FieldID)
		for _, f := range fields {
			if !instancemetadata.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != instancemetadata.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := imuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := imuo.mutation.IsRemote(); ok {
		_spec.SetField(instancemetadata.FieldIsRemote, field.TypeBool, value)
	}
	if value, ok := imuo.mutation.URI(); ok {
		_spec.SetField(instancemetadata.FieldURI, field.TypeString, value)
	}
	if value, ok := imuo.mutation.Extensions(); ok {
		_spec.SetField(instancemetadata.FieldExtensions, field.TypeJSON, value)
	}
	if value, ok := imuo.mutation.UpdatedAt(); ok {
		_spec.SetField(instancemetadata.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := imuo.mutation.Name(); ok {
		_spec.SetField(instancemetadata.FieldName, field.TypeString, value)
	}
	if value, ok := imuo.mutation.Description(); ok {
		_spec.SetField(instancemetadata.FieldDescription, field.TypeString, value)
	}
	if imuo.mutation.DescriptionCleared() {
		_spec.ClearField(instancemetadata.FieldDescription, field.TypeString)
	}
	if value, ok := imuo.mutation.Host(); ok {
		_spec.SetField(instancemetadata.FieldHost, field.TypeString, value)
	}
	if value, ok := imuo.mutation.PublicKey(); ok {
		_spec.SetField(instancemetadata.FieldPublicKey, field.TypeBytes, value)
	}
	if value, ok := imuo.mutation.PublicKeyAlgorithm(); ok {
		_spec.SetField(instancemetadata.FieldPublicKeyAlgorithm, field.TypeString, value)
	}
	if value, ok := imuo.mutation.PrivateKey(); ok {
		_spec.SetField(instancemetadata.FieldPrivateKey, field.TypeBytes, value)
	}
	if imuo.mutation.PrivateKeyCleared() {
		_spec.ClearField(instancemetadata.FieldPrivateKey, field.TypeBytes)
	}
	if value, ok := imuo.mutation.SoftwareName(); ok {
		_spec.SetField(instancemetadata.FieldSoftwareName, field.TypeString, value)
	}
	if value, ok := imuo.mutation.SoftwareVersion(); ok {
		_spec.SetField(instancemetadata.FieldSoftwareVersion, field.TypeString, value)
	}
	if value, ok := imuo.mutation.SharedInboxURI(); ok {
		_spec.SetField(instancemetadata.FieldSharedInboxURI, field.TypeString, value)
	}
	if value, ok := imuo.mutation.ModeratorsURI(); ok {
		_spec.SetField(instancemetadata.FieldModeratorsURI, field.TypeString, value)
	}
	if imuo.mutation.ModeratorsURICleared() {
		_spec.ClearField(instancemetadata.FieldModeratorsURI, field.TypeString)
	}
	if value, ok := imuo.mutation.AdminsURI(); ok {
		_spec.SetField(instancemetadata.FieldAdminsURI, field.TypeString, value)
	}
	if imuo.mutation.AdminsURICleared() {
		_spec.ClearField(instancemetadata.FieldAdminsURI, field.TypeString)
	}
	if value, ok := imuo.mutation.LogoEndpoint(); ok {
		_spec.SetField(instancemetadata.FieldLogoEndpoint, field.TypeString, value)
	}
	if imuo.mutation.LogoEndpointCleared() {
		_spec.ClearField(instancemetadata.FieldLogoEndpoint, field.TypeString)
	}
	if value, ok := imuo.mutation.LogoMimeType(); ok {
		_spec.SetField(instancemetadata.FieldLogoMimeType, field.TypeString, value)
	}
	if imuo.mutation.LogoMimeTypeCleared() {
		_spec.ClearField(instancemetadata.FieldLogoMimeType, field.TypeString)
	}
	if value, ok := imuo.mutation.BannerEndpoint(); ok {
		_spec.SetField(instancemetadata.FieldBannerEndpoint, field.TypeString, value)
	}
	if imuo.mutation.BannerEndpointCleared() {
		_spec.ClearField(instancemetadata.FieldBannerEndpoint, field.TypeString)
	}
	if value, ok := imuo.mutation.BannerMimeType(); ok {
		_spec.SetField(instancemetadata.FieldBannerMimeType, field.TypeString, value)
	}
	if imuo.mutation.BannerMimeTypeCleared() {
		_spec.ClearField(instancemetadata.FieldBannerMimeType, field.TypeString)
	}
	if value, ok := imuo.mutation.SupportedVersions(); ok {
		_spec.SetField(instancemetadata.FieldSupportedVersions, field.TypeJSON, value)
	}
	if value, ok := imuo.mutation.AppendedSupportedVersions(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, instancemetadata.FieldSupportedVersions, value)
		})
	}
	if value, ok := imuo.mutation.SupportedExtensions(); ok {
		_spec.SetField(instancemetadata.FieldSupportedExtensions, field.TypeJSON, value)
	}
	if value, ok := imuo.mutation.AppendedSupportedExtensions(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, instancemetadata.FieldSupportedExtensions, value)
		})
	}
	if imuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.UsersTable,
			Columns: instancemetadata.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imuo.mutation.RemovedUsersIDs(); len(nodes) > 0 && !imuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.UsersTable,
			Columns: instancemetadata.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imuo.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.UsersTable,
			Columns: instancemetadata.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if imuo.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.ModeratorsTable,
			Columns: instancemetadata.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imuo.mutation.RemovedModeratorsIDs(); len(nodes) > 0 && !imuo.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.ModeratorsTable,
			Columns: instancemetadata.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imuo.mutation.ModeratorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.ModeratorsTable,
			Columns: instancemetadata.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if imuo.mutation.AdminsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.AdminsTable,
			Columns: instancemetadata.AdminsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imuo.mutation.RemovedAdminsIDs(); len(nodes) > 0 && !imuo.mutation.AdminsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.AdminsTable,
			Columns: instancemetadata.AdminsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := imuo.mutation.AdminsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   instancemetadata.AdminsTable,
			Columns: instancemetadata.AdminsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &InstanceMetadata{config: imuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, imuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{instancemetadata.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	imuo.mutation.done = true
	return _node, nil
}
